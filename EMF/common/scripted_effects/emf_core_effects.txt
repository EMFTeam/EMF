# -*- ck2.scripted_effects -*-


emf_stop_hiding = {
	if = {
		limit = { trait = in_hiding }
		remove_trait = in_hiding
		add_character_modifier = { name = went_out_of_hiding_timer duration = 180 hidden = yes }
		hidden_tooltip = { character_event = { id = CM.6400 } } # Notify plotters and family
	}
}

# These do_not_disturb related effects are here for convenience as well as primarily a means of centralizing code which deals
# with this status, should we ever switch to an alterate design based-upon automatically-expiring, timed, and hidden
# character modifiers.

emf_do_not_disturb = {
	set_flag = do_not_disturb
}

emf_see_god = {
	isis = { reverse_banish = PREV }
	death = { death_reason = death_missing }
}

emf_vanish_character = {
	dynasty = none
	set_father = 0
	set_mother = 0
	any_spouse_even_if_dead = { remove_spouse = PREV }
	any_consort = { remove_consort = PREV }
	any_lover = { remove_lover = PREV }
	any_ward = { remove_guardian = yes }
	any_friend = { remove_friend = PREV }
	any_rival = { remove_rival = PREV }
	any_claim = { remove_claim = PREV }
	# A reminder that you definitely do not want to use emf_vanish_character on a high-born with children, or
	# dynasty trees will break (unless they are the dynasty founder and have only one dynastic child, I guess).
	if = {
		limit = { is_female = no }
		any_child_even_if_dead = { set_father = 0 }
	}
	else = {
		any_child_even_if_dead = { set_mother = 0 }
	}
	# Part of all this extra state clearing is to increase the chances that the dead character will be culled
	# entirely by the game on save/reload.
	emf_remove_all_traits = yes
	if = {
		limit = { is_alive = yes }
		clear_persistent_event_target = pet_parent_dyn
		death = { death_reason = death_missing }
	}
}

emf_make_location_ROOT_capital = {
	if = {
		limit = {
			ROOT = { is_nomadic = no } # Can't seem to set nomad capitals by event (tested last in 2.4)
			location = {
				owner = { character = ROOT } # Must own the province in order to make it capital, of course
				NOT = { # Location not already our capital
					ROOT = {
						capital_scope = { province = PREVPREV }
					}
				}
			}
		}
		custom_tooltip = {
			text = emf_ctt_make_location_ROOT_capital
			hidden_tooltip = {
				location = { ROOT = { capital = PREV } }
			}
		}
		# MAYBE-SOMEDAY-TODO: this'd be a place to call a hook which does some stuff whenever a ruler capital changes
	}
}

# THIS = ruler to subjugate, ROOT = new liege
emf_ROOT_subjugate_ruler = {
	if = {
		limit = { NOT = { vassal_of = ROOT } }
		ROOT = { save_event_target_as = emf_cb_new_imperial_liege }
		emf_set_viceroy_exemption = yes
		set_defacto_liege = ROOT
		hidden_effect = {
			if = {
				limit = { vassal_of = ROOT }
				emf_liege_change = yes
				if = {
					limit = { religion = ROOT }
					opinion = { who = ROOT modifier = opinion_subjugated }
				}
				else = {
					opinion = { who = ROOT modifier = opinion_subjugated_other_rel }
				}
			}
			else = {
				log = "WARNING: emf_ROOT_subjugate_ruler: failed to vassalize [This.EMF_GetDebugName] to [Root.EMF_GetDebugName]"
			}
		}
	}
}

# THIS = ruler to subjugate, FROM = new liege
emf_FROM_subjugate_ruler = {
	if = {
		limit = { NOT = { vassal_of = FROM } }
		FROM = { save_event_target_as = emf_cb_new_imperial_liege }
		emf_set_viceroy_exemption = yes
		set_defacto_liege = FROM
		hidden_effect = {
			if = {
				limit = { vassal_of = FROM }
				emf_liege_change = yes
				if = {
					limit = { religion = FROM }
					opinion = { who = FROM modifier = opinion_subjugated }
				}
				else = {
					opinion = { who = FROM modifier = opinion_subjugated_other_rel }
				}
			}
			else = {
				log = "WARNING: emf_FROM_subjugate_ruler: failed to vassalize [This.EMF_GetDebugName] to [From.EMF_GetDebugName]"
			}
		}
	}
}

# THIS = tributary, ROOT = potential suzerain which has THIS as a tribute; that tributary relation will be removed.
emf_remove_suzerain_under_ROOT = {
	if = {
		limit = {
			is_tributary = yes
			suzerain = { under_ROOT = yes }
		}
		suzerain = { remove_tributary = PREV }
	}
}

# THIS = tributary, FROM = potential suzerain (merely scope variant)
emf_remove_suzerain_under_FROM = {
	if = {
		limit = {
			is_tributary = yes
			suzerain = { under_FROM = yes }
		}
		suzerain = { remove_tributary = PREV }
	}
}

emf_liege_change = {
	hidden_tooltip = {
		pf_liege_change_effect = yes
		if = {
			limit = {
				independent = no
				is_tributary = yes
			}
			any_suzerain = { remove_tributary = PREV }
		}
		# Remove any invalidated protected_appointment opinions due to liege change
		any_opinion_modifier_target = {
			limit = {
				reverse_has_opinion_modifier = { who = PREV modifier = opinion_protected_appointment_always }
				NOT = { is_liege_of = PREV }
			}
			reverse_remove_opinion = { who = PREV modifier = opinion_protected_appointment_always }
		}
	}
}

emf_remove_plot_assisted_spying = {
	if = {
		limit = {
			OR = {
				has_character_modifier = plot_assisted_spying
				has_character_modifier = plot_assisted_spying2
				has_character_modifier = plot_assisted_spying3
				has_character_modifier = plot_assisted_spying4
				has_character_modifier = plot_assisted_spying5
			}
		}
		remove_character_modifier = plot_assisted_spying
		remove_character_modifier = plot_assisted_spying2
		remove_character_modifier = plot_assisted_spying3
		remove_character_modifier = plot_assisted_spying4
		remove_character_modifier = plot_assisted_spying5
	}
}
