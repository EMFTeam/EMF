# -*- ck2.events -*-

namespace = emf_cadet

# emf_cadet.0 -- inherit dynasty founder PET [on_birth & triggered by legitimization events + emf_new_character]
character_event = {
	id = emf_cadet.0

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		is_lowborn = no
		OR = {
			father_even_if_dead = {
				dynasty = ROOT
				persistent_event_target:emf_dynasty_founder = {
					dynasty = ROOT
				}
			}
			mother_even_if_dead = {
				dynasty = ROOT
				persistent_event_target:emf_dynasty_founder = {
					dynasty = ROOT
				}
			}
		}
	}

	immediate = {
		# Determine which parent holds the PET we want to inherit:
		if = {
			limit = {
				father_even_if_dead = {
					dynasty = ROOT
					persistent_event_target:emf_dynasty_founder = {
						dynasty = ROOT
					}
				}
			}
			father_even_if_dead = {
				save_event_target_as = emf_dynastic_parent
			}
		}
		else = {
			mother_even_if_dead = {
				save_event_target_as = emf_dynastic_parent
			}
		}
		# Inherit the PET:
		event_target:emf_dynastic_parent = {
			persistent_event_target:emf_dynasty_founder = {
				ROOT = {
					save_persistent_event_target = {
						name = emf_dynasty_founder
						scope = PREV
					}
				}
			}
		}
	}
}

# emf_cadet.1 -- character is born unto a `bastard` of a cadet dynasty member, so the emf_dynasty_founder PET must
# be cleared on both parent and child, because the hard-code will have randomly flipped them to a new, random
# dynasty. in the future, it'd be nice if we could, instead of erasing the dynasty founder PET, set the PET to
# point at the bastard, but for now, no fanciness for bastard dynasties. [on_birth]
character_event = {
	id = emf_cadet.1

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		OR = {
			father_even_if_dead = {
				dynasty = ROOT
				persistent_event_target:emf_dynasty_founder = {
					NOT = { dynasty = ROOT }
				}
			}
			mother_even_if_dead = {
				dynasty = ROOT
				persistent_event_target:emf_dynasty_founder = {
					NOT = { dynasty = ROOT }
				}
			}
		}
	}

	immediate = {
		# Determine which parent(s) created the PET incoherency (e.g., were a bastard) & clear their PETs:
		if = {
			limit = {
				father_even_if_dead = {
					dynasty = ROOT
					persistent_event_target:emf_dynasty_founder = {
						NOT = { dynasty = ROOT }
					}
				}
			}
			father_even_if_dead = {
				clear_persistent_event_target = emf_dynasty_founder
			}
		}
		if = {
			limit = {
				mother_even_if_dead = {
					dynasty = ROOT
					persistent_event_target:emf_dynasty_founder = {
						NOT = { dynasty = ROOT }
					}
				}
			}
			mother_even_if_dead = {
				clear_persistent_event_target = emf_dynasty_founder
			}
		}
	}
}

# emf_cadet.10 -- flag cadets [on_yearly_pulse]
character_event = {
	id = emf_cadet.10

	is_triggered_only = yes
	hide_window = yes

	only_capable = yes
	min_age = 16 # Adults only
	ai = yes

	trigger = {
		# No females permitted to become cadets unless Gender Equality GR is set to Full
		OR = {
			is_female = no
			has_game_rule = { name = gender value = all }
		}
		is_lowborn = no
		is_ruler = no
		# Note that we don't evaluate gender preference until/if the potential cadet gains a title (and then use that
		# title's gender succession law for preference).
		NOR = {
			# Not already a cadet & not a cadet that was later disqualified
			has_flag = emf_cadet
			has_flag = emf_disqualified_cadet
			trigger_if = {
				limit = { is_female = no }
				is_married_matrilineally = yes # No matrilineally married males
			}
			trigger_else = {
				# No females with regular marriages:
				is_married = yes
				NOT = { is_married_matrilineally = yes }
			}
			# Cannot be heir to any title that's not a barony in someone else's capital county (emf_gavelkind would take
			# their barony away anyway). Note if they were actually heir to the associated county, this would fail:
			any_heir_title = {
				NAND = {
					tier = BARON
					location = {
						is_capital = yes
						owner = {
							higher_real_tier_than = COUNT
							is_nomadic = no
							is_merchant_republic = no
						}
					}
				}
			}
		}
		# Must have an older sibling that could technically inherit:
		OR = {
			father_even_if_dead = {
				dynasty = ROOT
				any_child = {
					NOT = { character = ROOT }
					dynasty = PREV
					is_older_than = ROOT
					OR = {
						is_female = no
						has_game_rule = { name = gender value = all }
					}
					emf_can_inherit = yes
				}
			}
			mother_even_if_dead = {
				dynasty = ROOT
				any_child = {
					NOT = { character = ROOT }
					dynasty = PREV
					is_older_than = ROOT
					OR = {
						is_female = no
						has_game_rule = { name = gender value = all }
					}
					emf_can_inherit = yes
				}
			}
		}
		dynasty_head = {
			NOR = {
				character = ROOT # Cadets are not dynasty heads.
				# No marriage ties to cadet spouses or close relative relationship to cadet's children:
				ROOT = {
					OR = {
						any_child = {
							is_close_relative = PREVPREV
						}
						any_spouse = {
							is_close_relative = PREVPREV
						}
					}
				}
			}
			trigger_if = {
				limit = { culture = ROOT }
				# Since of same culture as dynasty head, neither cadet's parents nor himself should be close relatives of
				# THIS dynasty_head.
				NOR = {
					is_close_relative = ROOT
					ROOT = {
						OR = {
							father_even_if_dead = {
								is_close_relative = PREVPREV
							}
							mother_even_if_dead = {
								is_close_relative = PREVPREV
							}
						}
					}
				}
			}
			trigger_else = {
				# Since of different culture as dynasty head, we only require that the dynasty head is neither the father nor
				# the mother of the cadet.
				NOR = {
					is_father = ROOT
					is_mother = ROOT
				}
			}
		}
		# Dynasty must have at least 30 other living members:
		any_dynasty_member = { count = 30 is_alive = yes }
	}

	immediate = {
		set_flag = emf_cadet
		log = "DEBUG: emf_cadet.10: potential cadet: [This.EMF_GetDebugName]"
	}
}

# emf_cadet.11 -- disqualify cadets [on_yearly_pulse]
character_event = {
	id = emf_cadet.11

	is_triggered_only = yes
	hide_window = yes

	has_character_flag = emf_cadet # exclusive with emf_disqualified_cadet
	ai = yes

	trigger = {
		emf_is_cadet_disqualified = yes
	}

	immediate = {
		log = "DEBUG: emf_cadet.11: disqualifying potential cadet: [This.EMF_GetDebugName]"
		clr_flag = emf_cadet
		set_flag = emf_disqualified_cadet
	}
}


# emf_cadet.12 -- check whether an emf_cadet can form a cadet dynasty [on_yearly_pulse]
character_event = {
	id = emf_cadet.12

	is_triggered_only = yes
	hide_window = yes

	only_playable = yes # COUNT+ (or patrician) required to advance to cadet dynasty formation
	only_capable = yes
	prisoner = no
	war = no
	has_character_flag = emf_cadet

	trigger = {
		# Proper type of government and primary title:
		OR = {
			is_feudal = yes
			is_tribal = yes
			is_patrician = yes
		}
		primary_title = {
			NOR = {
				mercenary = yes
				holy_order = yes
				temporary = yes
				rebel = yes
				has_flag = emf_revolt
			}
		}
		emf_is_cadet_disqualified = no
		# Avoid forming cadet dynasties with player dynastic progeny (players don't want to have their dynasty up and
		# switched on them, although mechanically it's fine):
		NOT = {
			any_player = {
				dynasty = ROOT
				OR = {
					is_child_of = ROOT
					is_grandchild_of = ROOT
					father_even_if_dead = { is_grandchild_of = ROOT }
					mother_even_if_dead = { is_grandchild_of = ROOT }
				}
			}
		}
		# Must have a valid direct heir of our own dynastic progeny:
		player_heir = {
			is_alive = yes
			dynasty = ROOT
			OR = {
				is_child_of = ROOT
				is_grandchild_of = ROOT
				father_even_if_dead = { is_grandchild_of = ROOT }
				mother_even_if_dead = { is_grandchild_of = ROOT }
			}
		}
		# Dynasty must have at least 30 other living members:
		any_dynasty_member = { count = 30 is_alive = yes }
	}

	immediate = {
		log = "DEBUG: emf_cadet.12: ruler cadet qualified for formation of a cadet dynasty: [This.EMF_GetDebugName]"
		# Actually found the cadet dynasty:
		character_event = { id = emf_cadet.100 }
	}
}

# emf_cadet.100 -- ruler founds a cadet dynasty
character_event = {
	id = emf_cadet.100

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		# Can't be lowborn for this to work:
		is_lowborn = no
		# Cannot form a cadet dynasty with the same character twice in their lifetime:
		NOT = { has_flag = emf_founded_cadet_dynasty }
		# Must own the county of our own capital:
		capital_scope = { owner = { character = ROOT } }
		# At least one of our parents has to share our own dynasty:
		OR = {
			father_even_if_dead = { dynasty = ROOT }
			mother_even_if_dead = { dynasty = ROOT }
		}
		# Bastard dynasties are a different thing than cadet dynasties (and the hard-coded dynasty change mechanics for
		# the bastard trait would make creating a cadet dynasty pointless anyhow):
		NOT = { trait = bastard }
		# Must not have a temporary title of any kind:
		emf_has_no_temporary_title = yes
	}

	immediate = {
		log = "DEBUG: emf_cadet.100: forming new cadet dynasty: [This.EMF_GetDebugName]"
		emf_log_cadet_info = yes
		set_flag = emf_founded_cadet_dynasty
		save_event_target_as = emf_cadet
		# Save event target to parent of the old dynasty & instantiate a new dynasty in ROOT:
		if = {
			limit = {
				father_even_if_dead = {
					dynasty = ROOT
				}
			}
			father_even_if_dead = { save_event_target_as = emf_old_dynasty }
			dynasty = father_bastard
		}
		else = {
			mother_even_if_dead = { save_event_target_as = emf_old_dynasty }
			dynasty = mother_bastard
		}
		log = " --> parent dynasty: [emf_old_dynasty.GetOnlyDynastyName]"
		event_target:emf_old_dynasty = {
			primary_title = {
				if = {
					limit = { emf_has_any_succ_law = yes }
					log = " ----> succession law: [This.EMF_GetFullSuccLaw]"
				}
			}
		}
		# Save a PET pointing to that parent so that we can later determine our parent dynasty conveniently:
		save_persistent_event_target = {
			name = emf_parent_dynasty
			scope = event_target:emf_old_dynasty
		}
		# If we were already of a cadet dynasty, save an event target to the dynasty's founder, else we'd overwrite
		# it forever in the following step:
		persistent_event_target:emf_dynasty_founder = {
			log = " ----> is a cadet dynasty, and its founder was: [This.EMF_GetDebugName]"
			save_event_target_as = emf_old_dynasty_founder
		}
		# Recursively convert all dynastic progeny (old dynasty) to ROOT's new dynasty (incl. ROOT):
		log = " --> converting to new dynasty:"
		character_event = { id = emf_cadet.101 }
		# Loggin' like a lumberjack:
		event_target:emf_old_dynasty = { emf_count_dynasty_members = yes }
		log = " --> members of old dynasty: [local_alive_members.GetValue] alive + [local_dead_members.GetValue] dead = [local_total_members.GetValue] total"
		emf_count_dynasty_members = yes
		log = " --> members of new dynasty: [local_alive_members.GetValue] alive + [local_dead_members.GetValue] dead = [local_total_members.GetValue] total"
		# Recalculate succession for rulers of the old and new dynasty:
		event_target:emf_old_dynasty = {
			any_dynasty_member = {
				limit = { is_ruler = yes }
				recalc_succession = yes
			}
		}
		any_dynasty_member = {
			limit = {
				is_ruler = yes
				NOT = { character = ROOT }
			}
			recalc_succession = yes
		}
		recalc_succession = yes
		# Create three dummy characters (we'll throw them away afterward) for crazy workarounds to improve dynasty naming
		# despite lack of any string processing capabilities in CK2script. We marshal various types of names into their
		# actual dynasty names, and then we marshal the last word in those "dynasty names" into the dummy characters'
		# first name so that we can use the same_regnal_name trigger to compare names of things for equality.
		#
		# Dummy1's usage is dependent upon the type of dynasty naming schema we're going to use and is used to prevent
		# things like a cadet dynasty forming with the same name as its parent dynasty or creating a cadet dynasty name
		# with a douple-hyphenation such as "de Valois-Valois."
		#
		# Dummy2's usage will hold the last word of a title name as we try to select an appropriate match with Dummy1. If
		# an appropriate selection is made at this stage, then Dummy2 is overwritten with the proposed dynasty name based
		# upon the chosen naming schema.
		#
		# Dummy3 will hold the dynasty name (as the first name) of every playable ruler in the world as we loop over all
		# of them looking for a dynasty name collision with the proposed dynasty name. If we collide, the title we
		# selected for dynasty naming will be marked as such and the process will start over, falling back to
		# lower-priority title names, and failing all of that, eventually stop caring about the dynasty name collision
		# and return to the highest-priority selections.
		create_character = { random_traits = no dynasty = random }
		new_character = { save_event_target_as = emf_dummy1 }
		create_character = { random_traits = no dynasty = random }
		new_character = { save_event_target_as = emf_dummy2 }
		create_character = { random_traits = no dynasty = random }
		new_character = { save_event_target_as = emf_dummy3 }
		# Now, let's rename this new dynasty to something remotely intelligible. We have 4 main cases:
		# 0. ROOT's culture uses founder-named dynasties
		# 1. ROOT's tier is higher than DUKE, or their primary title is a special-type title
		# 2. ROOT's parent dynasty has a paired title PET (ergo, must be cadet of cadet)
		# 3. ROOT's parent dynasty has no paired title PET (might be standard cadet formation or a cadet of case 1)
		if = {
			limit = {
				emf_uses_founder_named_dynasties = yes
			}
			# Do nothing (hard-code already gave us a founder-named dynasty name)
			log = " --> cadet dynasty name will be a founder-named dynasty (case 0)"
		}
		else_if = {
			limit = {
				higher_tier_than = DUKE
			}
			log = " --> cadet dynasty name will be composed from a single title name (case 1)"
			# In this case, we're not going to try to pair a prior dynasty name component with a title, and we're going to
			# use a non-hyphenated format. Our concern shifts to making sure that we select a title which does not amount to
			# generating basically (or exactly) the same cadet dynasty name as its parent dynasty name.
			#
			# Set the first dummy's given name to the last word in the parent dynasty's name:
			event_target:emf_dummy1 = {
				set_dynasty_name = "[emf_old_dynasty.GetOnlyDynastyName]"
				set_name = "[This.GetLastWordInDynastyName]"
			}
			set_flag = emf_cadet_tmp_name_schema_1
			emf_select_cadet_dynasty_name = yes
			if = {
				limit = { event_target:emf_selected_title = { always = yes } }
				set_dynasty_name = "[emf_dummy2.GetOnlyDynastyName]"
			}
		}
		else_if = {
			limit = {
				event_target:emf_old_dynasty_founder = {
					persistent_event_target:emf_dynasty_paired_title = { always = yes }
				}
			}
			log = " --> trying to compose cadet dynasty from the parent dynasty's paired title and a demesne title (case 2)"
			event_target:emf_old_dynasty_founder = {
				persistent_event_target:emf_dynasty_paired_title = {
					save_event_target_as = emf_paired_title
				}
			}
			log = " ----> parent dynasty's paired title: [emf_paired_title.EMF_GetDebugTitleNameWithDeJureLieges]"
			# Set the first dummy's given name to the last word in the parent dynasty's paired title:
			event_target:emf_dummy1 = {
				set_dynasty_name = "[emf_paired_title.GetBaseName]"
				set_name = "[This.GetLastWordInDynastyName]"
			}
			# Now, starting with our primary title and descending downward among demesne titles, find the first demesne
			# title that wouldn't result in a "double-hyphenation" (e.g., de Valois-Valois should fail and then de
			# Valois-Vermandois could be a valid fallback):
			set_flag = emf_cadet_tmp_name_schema_2
			emf_select_cadet_dynasty_name = yes
			if = {
				limit = { event_target:emf_selected_title = { always = yes } }
				set_dynasty_name = "[emf_dummy2.GetOnlyDynastyName]"
				save_persistent_event_target = {
					name = emf_dynasty_paired_title
					scope = event_target:emf_selected_title
				}
			}
		}
		else = {
			log = " --> trying to compose dynasty name from the parent dynasty's name and our primary title (case 3)"
			# Set the first dummy's given name to the last word in the parent dynasty's name:
			event_target:emf_dummy1 = {
				set_dynasty_name = "[emf_old_dynasty.GetOnlyDynastyName]"
				set_name = "[This.GetLastWordInDynastyName]"
			}
			# Now, starting with our primary title and descending downward among demesne titles, find the first demesne
			# title that wouldn't result in a "double-hyphenation" or similar:
			set_flag = emf_cadet_tmp_name_schema_3
			emf_select_cadet_dynasty_name = yes
			if = {
				limit = { event_target:emf_selected_title = { always = yes } }
				set_dynasty_name = "[emf_dummy2.GetOnlyDynastyName]"
				save_persistent_event_target = {
					name = emf_dynasty_paired_title
					scope = event_target:emf_selected_title
				}
			}
		}
		log = " --> final dynasty name: [This.GetOnlyDynastyName]"
		# Cleanup dummy characters:
		event_target:emf_dummy1 = { emf_vanish_character = yes }
		event_target:emf_dummy2 = { emf_vanish_character = yes }
		event_target:emf_dummy3 = { emf_vanish_character = yes }
		# Onward!
			}
		}
	}
}

# emf_cadet.101 -- recursively convert ROOT and all emf_old_dynasty dynastic progeny to the dynasty of emf_cadet &
# save persistent event targets in them also pointing to emf_cadet
character_event = {
	id = emf_cadet.101

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		NOT = { trait = emf_temporary }
	}

	immediate = {
		# We use the emf_temporary trait as a guard against infinite recursion in the rare event that some serious incest
		# has caused cycles in the dynasty tree of the cadet's dynastic progeny:
		add_trait = emf_temporary
		any_child_even_if_dead = {
			limit = { dynasty = event_target:emf_old_dynasty }
			character_event = { id = emf_cadet.101 } # Recurse
		}
		remove_trait = emf_temporary
		log = " ----> switching to cadet dynasty: [This.EMF_GetDebugName]"
		dynasty = event_target:emf_cadet
		save_persistent_event_target = {
			name = emf_dynasty_founder
			scope = event_target:emf_cadet
		}
		if = {
			limit = {
				is_alive = yes
				ai = no
				NOT = { character = event_target:emf_cadet }
			}
			log = " ------> is a player!"
			character_event = { id = emf_cadet.202 days = 1 } # Notify of dynasty change
		}
	}
}

#### NOTIFICATIONS ####

# emf_cadet.200 -- notify vassals & close relatives not of the new cadet dynasty of the cadet dynasty formation
character_event = {
	id = emf_cadet.200
	desc = placeholder_a # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}

# emf_cadet.201 -- notify members of the old dynasty of the cadet dynasty formation
character_event = {
	id = emf_cadet.201
	desc = placeholder_b # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}

# emf_cadet.202 -- notify new members of the cadet dynasty of the cadet dynasty formation
character_event = {
	id = emf_cadet.202
	desc = placeholder_c # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}

# emf_cadet.203 -- notify the cadet of the cadet dynasty's formation
character_event = {
	id = emf_cadet.203
	desc = placeholder_d # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}
