# -*- ck2.events -*-

namespace = emf_cadet

# emf_cadet.0 -- inherit dynasty founder PET [on_birth & triggered by legitimization events + emf_new_character]
character_event = {
	id = emf_cadet.0

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		is_lowborn = no
		OR = {
			father = {
				dynasty = ROOT
				persistent_event_target:emf_cadet_dyn_founder = {
					dynasty = ROOT
				}
			}
			mother = {
				OR = {
					AND = {
						dynasty = ROOT
						persistent_event_target:emf_cadet_dyn_founder = {
							dynasty = ROOT
						}
					}
					# If the father dies during pregnancy, we use this PET saved before he died:
					persistent_event_target:emf_cadet_dyn_founder_of_unborn = {
						dynasty = ROOT
					}
				}
			}
		}
	}

	immediate = {
		# Determine which PETs we want to inherit:
		if = {
			limit = {
				father = {
					dynasty = ROOT
					persistent_event_target:emf_cadet_dyn_founder = {
						dynasty = ROOT
					}
				}
			}
			father = {
				persistent_event_target:emf_cadet_dyn_founder = {
					save_event_target_as = emf_dynasty_founder
				}
				persistent_event_target:emf_parent_dyn = {
					save_event_target_as = emf_parent_dynasty
				}
			}
		}
		else_if = {
			limit = {
				mother = {
					dynasty = ROOT
					persistent_event_target:emf_cadet_dyn_founder = {
						dynasty = ROOT
					}
				}
			}
			mother = {
				persistent_event_target:emf_cadet_dyn_founder = {
					save_event_target_as = emf_dynasty_founder
				}
				persistent_event_target:emf_parent_dyn = {
					save_event_target_as = emf_parent_dynasty
				}
			}
		}
		else = {
			mother = {
				persistent_event_target:emf_cadet_dyn_founder_of_unborn = {
					save_event_target_as = emf_dynasty_founder
				}
				persistent_event_target:emf_parent_dyn_of_unborn = {
					save_event_target_as = emf_parent_dynasty
				}
			}
		}
		# Inherit the PETs:
		event_target:emf_dynasty_founder = {
			ROOT = {
				save_persistent_event_target = {
					name = emf_cadet_dyn_founder
					scope = PREV
				}
			}
		}
		event_target:emf_parent_dynasty = {
			ROOT = {
				save_persistent_event_target = {
					name = emf_parent_dyn
					scope = PREV
				}
			}
		}
	}
}

# emf_cadet.1 -- character is born unto a `bastard` of a cadet dynasty member, so the emf_dynasty_founder PET must
# be cleared on both parent and child, because the hard-code will have randomly flipped them to a new, random
# dynasty. in the future, it'd be nice if we could, instead of erasing the dynasty founder PET, set the PET to
# point at the bastard, but for now, no fanciness for bastard dynasties. [on_birth]
character_event = {
	id = emf_cadet.1

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		is_lowborn = no
		OR = {
			father = {
				persistent_event_target:emf_cadet_dyn_founder = {
					NOT = { dynasty = PREV }
				}
			}
			mother = {
				OR = {
					persistent_event_target:emf_cadet_dyn_founder = {
						NOT = { dynasty = PREV }
					}
					# If the father dies during pregnancy, we use this PET saved before he died:
					persistent_event_target:emf_cadet_dyn_founder_of_unborn = {
						NOT = { dynasty = ROOT }
					}
				}
			}
		}
	}

	immediate = {
		# Determine which parent(s) created the PET incoherency (e.g., were a bastard) & clear their PETs:
		if = {
			limit = {
				father = {
					persistent_event_target:emf_cadet_dyn_founder = {
						NOT = { dynasty = PREV }
					}
				}
			}
			father = {
				clear_persistent_event_target = emf_cadet_dyn_founder
				clear_persistent_event_target = emf_parent_dyn
			}
		}
		if = {
			limit = {
				mother = {
					persistent_event_target:emf_cadet_dyn_founder = {
						NOT = { dynasty = PREV }
					}
				}
			}
			mother = {
				clear_persistent_event_target = emf_cadet_dyn_founder
				clear_persistent_event_target = emf_parent_dyn
			}
		}
		clear_persistent_event_target = emf_cadet_dyn_founder
		clear_persistent_event_target = emf_parent_dyn
	}
}

# emf_cadet.2 -- clear temporary unborn cadet PETs saved on mother (ROOT) when father dies prematurely [on_birth,
# on_postbirth_stillbirth]
character_event = {
	id = emf_cadet.2

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		OR = {
			persistent_event_target:emf_cadet_dyn_founder_of_unborn = { always = yes }
			persistent_event_target:emf_parent_dyn_of_unborn = { always = yes }
		}
		# Don't clear the PETs if the woman is again somehow already pregnant and the father has yet again died
		# prematurely:
		OR = {
			is_pregnant = no
			father_of_unborn = { is_alive = yes }
		}
	}

	immediate = {
		# We delay the actual PET clearing by 1 day in case we're having twins today:
		character_event = { id = emf_cadet.3 days = 1 }
	}
}

# emf_cadet.3 -- actually clear the unborn cadet PETs 1 day after firing emf_cadet.2 from on_actions
character_event = {
	id = emf_cadet.3

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		OR = {
			persistent_event_target:emf_cadet_dyn_founder_of_unborn = { always = yes }
			persistent_event_target:emf_parent_dyn_of_unborn = { always = yes }
		}
		# Don't clear the PETs if the woman is again somehow already pregnant and the father has yet again died
		# prematurely:
		OR = {
			is_pregnant = no
			father_of_unborn = { is_alive = yes }
		}
	}

	immediate = {
		clear_persistent_event_target = emf_cadet_dyn_founder_of_unborn
		clear_persistent_event_target = emf_parent_dyn_of_unborn
	}
}

# emf_cadet.4 -- when father carrying cadet dynasty PETs dies with a pregnant wife in a patrilineal marriage, save
# copies of their cadet PETs to the mother for usage upon birth of the child [on_death]
character_event = {
	id = emf_cadet.4

	is_triggered_only = yes
	hide_window = yes

	only_men = yes

	trigger = {
		persistent_event_target:emf_cadet_dyn_founder = { always = yes }
		persistent_event_target:emf_parent_dyn = { always = yes }
		OR = {
			any_spouse = {
				is_pregnant = yes
				NOT = { is_married_matrilineally = yes }
			}
			any_consort = {
				is_pregnant = yes
				is_consort = yes # junior party
			}
		}
	}

	immediate = {
		persistent_event_target:emf_cadet_dyn_founder = {
			save_event_target_as = emf_dynasty_founder
		}
		persistent_event_target:emf_parent_dyn = {
			save_event_target_as = emf_parent_dynasty
		}
		any_spouse = {
			limit = {
				is_pregnant = yes
				NOT = { is_married_matrilineally = yes }
			}
			save_persistent_event_target = {
				name = emf_cadet_dyn_founder_of_unborn
				scope = event_target:emf_dynasty_founder
			}
			save_persistent_event_target = {
				name = emf_parent_dyn_of_unborn
				scope = event_target:emf_parent_dynasty
			}
		}
		any_consort = {
			limit = {
				is_pregnant = yes
				is_consort = yes # junior party
			}
			save_persistent_event_target = {
				name = emf_cadet_dyn_founder_of_unborn
				scope = event_target:emf_dynasty_founder
			}
			save_persistent_event_target = {
				name = emf_parent_dyn_of_unborn
				scope = event_target:emf_parent_dynasty
			}
		}
	}
}

# emf_cadet.10 -- flag cadets [on_yearly_pulse]
character_event = {
	id = emf_cadet.10

	is_triggered_only = yes
	hide_window = yes

	only_capable = yes
	min_age = 16 # Adults only
	ai = yes

	trigger = {
		# No females permitted to become cadets unless Gender Equality GR is set to Full
		OR = {
			is_female = no
			has_game_rule = { name = gender value = all }
		}
		is_lowborn = no
		is_ruler = no
		# Note that we don't evaluate gender preference until/if the potential cadet gains a title (and then use that
		# title's gender succession law for preference).
		NOR = {
			# Not already a cadet & not a cadet that was later disqualified
			has_flag = emf_cadet
			has_flag = emf_disqualified_cadet
			trait = bastard # Bastards create bastard dynasties -- not cadet dynasties
			trigger_if = {
				limit = { is_female = no }
				is_married_matrilineally = yes # No matrilineally married males
			}
			trigger_else = {
				# No females with regular marriages:
				is_married = yes
				NOT = { is_married_matrilineally = yes }
			}
			# Cannot be heir to any title that's not a barony in someone else's capital county (emf_gavelkind would take
			# their barony away anyway). Note if they were actually heir to the associated county, this would fail:
			any_heir_title = {
				NAND = {
					tier = BARON
					location = {
						is_capital = yes
						owner = {
							higher_real_tier_than = COUNT
							is_nomadic = no
							is_merchant_republic = no
						}
					}
				}
			}
		}
		# Must have an older sibling that could technically inherit:
		OR = {
			father_even_if_dead = {
				dynasty = ROOT
				any_child = {
					NOT = { character = ROOT }
					dynasty = PREV
					is_older_than = ROOT
					OR = {
						is_female = no
						has_game_rule = { name = gender value = all }
					}
					emf_can_inherit = yes
				}
			}
			mother_even_if_dead = {
				dynasty = ROOT
				any_child = {
					NOT = { character = ROOT }
					dynasty = PREV
					is_older_than = ROOT
					OR = {
						is_female = no
						has_game_rule = { name = gender value = all }
					}
					emf_can_inherit = yes
				}
			}
		}
		dynasty_head = {
			NOR = {
				character = ROOT # Cadets are not dynasty heads.
				# Has no marriage ties to cadet and none of cadet's children are close relatives of him:
				ROOT = {
					OR = {
						any_child = {
							is_close_relative = PREVPREV
						}
						any_spouse = {
							is_close_relative = PREVPREV
						}
					}
				}
			}
			trigger_if = {
				limit = {
					culture = ROOT
					emf_same_basic_religion_as_ROOT = yes
				}
				# Since of same culture as dynasty head, neither cadet's parents nor himself should be close relatives of
				# THIS dynasty_head.
				NOR = {
					is_close_relative = ROOT
					ROOT = {
						OR = {
							father_even_if_dead = {
								is_close_relative = PREVPREV
							}
							mother_even_if_dead = {
								is_close_relative = PREVPREV
							}
						}
					}
				}
			}
			trigger_else_if = {
				limit = {
					emf_same_basic_religion_as_ROOT = yes
				}
				# Since of different culture as dynasty head, we only require that the dynasty head is neither the
				# father nor the mother of the cadet.
				NOR = {
					is_father = ROOT
					is_mother = ROOT
				}
			}
			trigger_else = {
				# This code branch is just documentation and could be removed. Since of a different religion (where that's
				# defined as including heresies) and culture than dynasty_head, the dynasty_head has zero further restrictions
				# upon relation to us.
				always = yes
			}
		}
		# Dynasty must have at least 30 other living members, unless the cadet is a legitimized bastard. Why the
		# exception for legit bastards? We'd simply like to encourage them over others to break off and form their own
		# cadet dynasties. We'd encourage actual bastards, but the hard-coded bastard dynasty "feature" (dynasty randomly
		# changes upon birth of their first child) will not allow them to form a coherent cadet dynasty.
		OR = {
			trait = legit_bastard
			any_dynasty_member = { count = 30 is_alive = yes }
		}
	}

	immediate = {
		set_flag = emf_cadet
		log = "DEBUG: emf_cadet.10: potential cadet: [This.EMF_GetDebugName]"
	}
}

# emf_cadet.11 -- disqualify cadets [on_yearly_pulse]
character_event = {
	id = emf_cadet.11

	is_triggered_only = yes
	hide_window = yes

	min_age = 16
	has_character_flag = emf_cadet # exclusive with emf_disqualified_cadet
	ai = yes

	trigger = {
		emf_is_cadet_disqualified = yes
	}

	immediate = {
		log = "DEBUG: emf_cadet.11: disqualifying potential cadet: [This.EMF_GetDebugName]"
		clr_flag = emf_cadet
		set_flag = emf_disqualified_cadet
	}
}


# emf_cadet.12 -- check whether an emf_cadet can form a cadet dynasty [on_yearly_pulse]
character_event = {
	id = emf_cadet.12

	is_triggered_only = yes
	hide_window = yes

	only_playable = yes # COUNT+ (or patrician) required to advance to cadet dynasty formation
	only_capable = yes
	min_age = 16
	prisoner = no
	war = no
	has_character_flag = emf_cadet

	trigger = {
		# Proper type of government and primary title:
		OR = {
			is_feudal = yes
			is_tribal = yes
			is_patrician = yes
		}
		primary_title = {
			NOR = {
				mercenary = yes
				holy_order = yes
				temporary = yes
				rebel = yes
				has_flag = emf_revolt
			}
		}
		emf_is_cadet_disqualified = no
		# Avoid forming cadet dynasties with player dynastic progeny (players don't want to have their dynasty up and
		# switched on them, although mechanically it's fine):
		NOT = {
			any_player = {
				dynasty = ROOT
				OR = {
					is_child_of = ROOT
					is_grandchild_of = ROOT
					father_even_if_dead = { is_grandchild_of = ROOT }
					mother_even_if_dead = { is_grandchild_of = ROOT }
				}
			}
		}
		# Must have a valid direct heir of our own dynastic progeny:
		player_heir = {
			is_alive = yes
			dynasty = ROOT
			OR = {
				is_child_of = ROOT
				is_grandchild_of = ROOT
				father_even_if_dead = { is_grandchild_of = ROOT }
				mother_even_if_dead = { is_grandchild_of = ROOT }
			}
		}
		# Dynasty must have at least 30 other living members:
		any_dynasty_member = { count = 30 is_alive = yes }
	}

	immediate = {
		log = "DEBUG: emf_cadet.12: ruler cadet qualified for formation of a cadet dynasty: [This.EMF_GetDebugName]"
		# Actually found the cadet dynasty:
		character_event = { id = emf_cadet.100 }
	}
}

# emf_cadet.100 -- ruler founds a cadet dynasty
character_event = {
	id = emf_cadet.100

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		# Cannot form a cadet dynasty with the same character twice in their lifetime:
		NOT = { has_flag = emf_founded_cadet_dynasty }
		# Can't be lowborn for this to work:
		is_lowborn = no
		# Bastard dynasties are a different thing than cadet dynasties (and the hard-coded dynasty change mechanics for
		# the bastard trait would make creating a cadet dynasty pointless anyhow):
		NOT = { trait = bastard }
		# At least one of our parents has to share our own dynasty:
		OR = {
			father_even_if_dead = { dynasty = ROOT }
			mother_even_if_dead = { dynasty = ROOT }
		}
		# Must not have a temporary title of any kind:
		emf_has_no_temporary_title = yes
	}

	immediate = {
		log = "DEBUG: emf_cadet.100: forming new cadet dynasty: [This.EMF_GetDebugName]"
		emf_log_cadet_info = yes
		save_event_target_as = emf_cadet
		# Reset cadet flag & set founder flag:
		clr_flag = emf_cadet
		set_flag = emf_founded_cadet_dynasty
		# Save event target to parent of the old dynasty & instantiate a new dynasty in ROOT:
		if = {
			limit = {
				father_even_if_dead = {
					dynasty = ROOT
				}
			}
			father_even_if_dead = { save_event_target_as = emf_old_dynasty }
			dynasty = father_bastard
		}
		else = {
			mother_even_if_dead = { save_event_target_as = emf_old_dynasty }
			dynasty = mother_bastard
		}
		log = " --> parent dynasty: [emf_old_dynasty.GetOnlyDynastyName]"
		event_target:emf_old_dynasty = {
			primary_title = {
				if = {
					limit = { emf_has_any_succ_law = yes }
					log = " ----> succession law: [This.EMF_GetFullSuccLaw]"
				}
			}
		}
		# Clone the old dynasty character into an immortal character to hold our PETs forever (dead characters lose their
		# PETs after some number of game days)
		event_target:isis = {
			if = {
				limit = { event_target:emf_old_dynasty = { is_female = no } }
				create_character = {
					random_traits = no
					trait = immortal
					religion = event_target:emf_old_dynasty
					culture = event_target:emf_old_dynasty
					dynasty = random
					health = 10
					age = 32
					female = no
				}
			}
			else = {
				create_character = {
					random_traits = no
					trait = immortal
					religion = event_target:emf_old_dynasty
					culture = event_target:emf_old_dynasty
					dynasty = random
					health = 10
					age = 32
					female = yes
				}
			}
			new_character = {
				save_event_target_as = emf_immortal
				set_immune_to_pruning = yes
				set_flag = no_court_invites # Instructs AI to never accept an invitation to another court
				set_flag = ai_flag_refuse_conversion # Instructs AI to never accept Demand Religious Conversion
				set_flag = emf_cadet_immortal
				set_graphical_culture = hip_culture # Isis hive mind, but still the correct culture in case that matters
				set_dynasty_name = "[emf_old_dynasty.GetOnlyDynastyName]"
				copy_name = event_target:emf_old_dynasty
			}
		}
		# Copy our own emf_parent_dyn PET to the immortal (PET exists when we are part of a cadet dynasty)
		persistent_event_target:emf_parent_dyn = {
			event_target:emf_immortal = {
				save_persistent_event_target = {
					name = emf_parent_dyn
					scope = PREV
				}
			}
		}
		# Copy our own emf_cadet_dyn_founder PET to the immortal (PET exists when we are part of a cadet dynasty)
		persistent_event_target:emf_cadet_dyn_founder = {
			event_target:emf_immortal = {
				save_persistent_event_target = {
					name = emf_cadet_dyn_founder
					scope = PREV
				}
			}
		}
		# Recursively convert all dynastic progeny (old dynasty) to ROOT's new dynasty (incl. ROOT):
		log = " --> converting to new dynasty:"
		character_event = { id = emf_cadet.101 }
		# Loggin' like a lumberjack:
		event_target:emf_old_dynasty = { emf_count_dynasty_members = yes }
		log = " --> members of old dynasty: [isis.n_alive.GetValue] alive & [isis.n_dead.GetValue] dead ([isis.n_total.GetValue] total)"
		emf_count_dynasty_members = yes
		log = " --> members of new dynasty: [isis.n_alive.GetValue] alive & [isis.n_dead.GetValue] dead ([isis.n_total.GetValue] total)"
		# Recalculate succession for rulers of the old and new dynasty:
		event_target:emf_old_dynasty = {
			any_dynasty_member = {
				limit = { is_ruler = yes }
				recalc_succession = yes
			}
		}
		any_dynasty_member = {
			limit = {
				is_ruler = yes
				NOT = { character = ROOT }
			}
			recalc_succession = yes
		}
		recalc_succession = yes
		# Create three dummy characters (we'll throw them away afterward) for crazy workarounds to improve dynasty naming
		# despite lack of any string processing capabilities in CK2script. We marshal various types of names into their
		# actual dynasty names, and then we marshal the last word in those "dynasty names" into the dummy characters'
		# first name so that we can use the same_regnal_name trigger to compare names of things for equality.
		#
		# Dummy1's usage is dependent upon the type of dynasty naming schema we're going to use and is used to prevent
		# things like a cadet dynasty forming with the same name as its parent dynasty or creating a cadet dynasty name
		# with a douple-hyphenation such as "de Valois-Valois."
		#
		# Dummy2's usage will hold the last word of a title name as we try to select an appropriate match with Dummy1. If
		# an appropriate selection is made at this stage, then Dummy2 is overwritten with the proposed dynasty name based
		# upon the chosen naming schema.
		#
		# Dummy3 will hold the dynasty name (as the first name) of every playable ruler in the world as we loop over all
		# of them looking for a dynasty name collision with the proposed dynasty name. If we collide, the title we
		# selected for dynasty naming will be marked as such and the process will start over, falling back to
		# lower-priority title names, and failing all of that, eventually stop caring about the dynasty name collision
		# and return to the highest-priority selections.
		create_character = { random_traits = no dynasty = random }
		new_character = { save_event_target_as = emf_dummy1 }
		create_character = { random_traits = no dynasty = random }
		new_character = { save_event_target_as = emf_dummy2 }
		create_character = { random_traits = no dynasty = random }
		new_character = { save_event_target_as = emf_dummy3 }
		# Now, let's rename this new dynasty to something remotely intelligible. We have 4 main cases:
		# 0. ROOT's culture uses founder-named dynasties
		# 1. ROOT's tier is higher than DUKE, or their primary title is a special-type title
		# 2. ROOT's parent dynasty has a paired title PET (ergo, must be cadet of cadet)
		# 3. ROOT's parent dynasty has no paired title PET (might be standard cadet formation or a cadet of case 1)
		if = {
			limit = {
				emf_uses_founder_named_dynasties = yes
			}
			# Do nothing (hard-code already gave us a founder-named dynasty name)
			log = " --> cadet dynasty name will be a founder-named dynasty (case 0)"
			change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_0 value = 1 }
		}
		else_if = {
			limit = {
				higher_tier_than = DUKE
			}
			log = " --> cadet dynasty name will be composed from a single title name (case 1)"
			# In this case, we're not going to try to pair a prior dynasty name component with a title, and we're going to
			# use a non-hyphenated format. Our concern shifts to making sure that we select a title which does not amount to
			# generating basically (or exactly) the same cadet dynasty name as its parent dynasty name.
			#
			# Set the first dummy's given name to the last word in the parent dynasty's name:
			event_target:emf_dummy1 = {
				set_dynasty_name = "[emf_old_dynasty.GetOnlyDynastyName]"
				set_name = "[This.GetLastWordInDynastyName]"
			}
			set_flag = emf_cadet_tmp_name_schema_1
			emf_select_cadet_dynasty_name = yes
			if = {
				limit = { event_target:emf_selected_title = { always = yes } }
				set_dynasty_name = "[emf_dummy2.GetOnlyDynastyName]"
				change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_1 value = 1 }
			}
			else = {
				change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_1_fallback value = 1 }
			}
		}
		else_if = {
			limit = {
				event_target:emf_immortal = {
					persistent_event_target:emf_parent_dyn = {
						persistent_event_target:emf_dyn_title = { always = yes }
					}
				}
			}
			log = " --> trying to compose cadet dynasty from the parent dynasty's paired title and a demesne title (case 2)"
			event_target:emf_immortal = {
				persistent_event_target:emf_parent_dyn = {
					persistent_event_target:emf_dyn_title = {
						save_event_target_as = emf_paired_title
					}
				}
			}
			log = " ----> parent dynasty's paired title: [emf_paired_title.EMF_GetDebugTitleNameWithDeJureLieges]"
			# Set the first dummy's given name to the last word in the parent dynasty's paired title:
			event_target:emf_dummy1 = {
				set_dynasty_name = "[emf_paired_title.GetBaseName]"
				set_name = "[This.GetLastWordInDynastyName]"
			}
			# Now, starting with our primary title and descending downward among demesne titles, find the first demesne
			# title that wouldn't result in a "double-hyphenation" (e.g., de Valois-Valois should fail and then de
			# Valois-Vermandois could be a valid fallback):
			set_flag = emf_cadet_tmp_name_schema_2
			emf_select_cadet_dynasty_name = yes
			if = {
				limit = { event_target:emf_selected_title = { always = yes } }
				set_dynasty_name = "[emf_dummy2.GetOnlyDynastyName]"
				event_target:emf_immortal = {
					save_persistent_event_target = {
						name = emf_dyn_title
						scope = event_target:emf_selected_title
					}
				}
				change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_2 value = 1 }
			}
			else = {
				change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_2_fallback value = 1 }
			}
		}
		else = {
			log = " --> trying to compose dynasty name from the parent dynasty's name and our primary title (case 3)"
			# Set the first dummy's given name to the last word in the parent dynasty's name:
			event_target:emf_dummy1 = {
				set_dynasty_name = "[emf_old_dynasty.GetOnlyDynastyName]"
				set_name = "[This.GetLastWordInDynastyName]"
			}
			# Now, starting with our primary title and descending downward among demesne titles, find the first demesne
			# title that wouldn't result in a "double-hyphenation" or similar:
			set_flag = emf_cadet_tmp_name_schema_3
			emf_select_cadet_dynasty_name = yes
			if = {
				limit = { event_target:emf_selected_title = { always = yes } }
				set_dynasty_name = "[emf_dummy2.GetOnlyDynastyName]"
				event_target:emf_immortal = {
					save_persistent_event_target = {
						name = emf_dyn_title
						scope = event_target:emf_selected_title
					}
				}
				change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_3 value = 1 }
			}
			else = {
				change_variable = { which = global_cadet_dynasties_formed_w_naming_schema_3_fallback value = 1 }
			}
		}
		log = " --> final dynasty name: [This.GetOnlyDynastyName]"
		change_variable = { which = global_cadet_dynasties_formed value = 1 }
		# Cleanup dummy characters:
		event_target:emf_dummy1 = { emf_vanish_character = yes }
		event_target:emf_dummy2 = { emf_vanish_character = yes }
		event_target:emf_dummy3 = { emf_vanish_character = yes }
		# Onward!
			}
		}
	}
}

# emf_cadet.101 -- recursively convert ROOT and all emf_old_dynasty dynastic progeny to the dynasty of emf_cadet &
# save persistent event targets in them also pointing to emf_cadet
character_event = {
	id = emf_cadet.101

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		NOT = { trait = emf_temporary }
	}

	immediate = {
		# We use the emf_temporary trait as a guard against infinite recursion in the rare event that some serious incest
		# has caused cycles in the dynasty tree of the cadet's dynastic progeny:
		add_trait = emf_temporary
		any_child_even_if_dead = {
			limit = { dynasty = event_target:emf_old_dynasty }
			character_event = { id = emf_cadet.101 } # Recurse
		}
		remove_trait = emf_temporary
		log = " ----> switching to cadet dynasty: [This.EMF_GetDebugName]"
		dynasty = event_target:emf_cadet
		save_persistent_event_target = {
			name = emf_parent_dyn
			scope = event_target:emf_immortal
		}
		save_persistent_event_target = {
			name = emf_cadet_dyn_founder
			scope = event_target:emf_cadet
		}
		if = {
			limit = {
				is_alive = yes
				ai = no
				NOT = { character = event_target:emf_cadet }
			}
			log = " ------> is a player!"
			character_event = { id = emf_cadet.202 days = 1 } # Notify of dynasty change
		}
	}
}

#### NOTIFICATIONS ####

# emf_cadet.200 -- notify vassals & close relatives not of the new cadet dynasty of the cadet dynasty formation
character_event = {
	id = emf_cadet.200
	desc = placeholder_a # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}

# emf_cadet.201 -- notify members of the old dynasty of the cadet dynasty formation
character_event = {
	id = emf_cadet.201
	desc = placeholder_b # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}

# emf_cadet.202 -- notify new members of the cadet dynasty of the cadet dynasty formation
character_event = {
	id = emf_cadet.202
	desc = placeholder_c # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}

# emf_cadet.203 -- notify the cadet of the cadet dynasty's formation
character_event = {
	id = emf_cadet.203
	desc = placeholder_d # FIXME
	picture = GFX_evt_bloody_man # FIXME: an event picture appropriate for a cadet dynasty formation!
	border = GFX_event_normal_frame_diplomacy

	is_triggered_only = yes

	option = {
		name = OK # FIXME
	}
}
