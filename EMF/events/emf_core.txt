# -*- ck2.events -*-


namespace = emf_core

# emf_core.0 [Player]
#
# on_death handler for player characters. Inherits intrigue
# menu character flag state for now. Cushy.
character_event = {
	id = emf_core.0
	hide_window = yes
	is_triggered_only = yes
	
	ai = no

	immediate = {
		current_heir = {
			if = {
				limit = { ROOT = { has_character_flag = emf_toggle_customization_off } }
				set_character_flag = emf_toggle_customization_off
			}
			if = {
				limit = { ROOT = { has_character_flag = emf_toggle_employment } }
				set_character_flag = emf_toggle_employment
			}
			if = {
				limit = { ROOT = { has_character_flag = enable_marriage_decisions } }
				set_character_flag = enable_marriage_decisions
			}
			if = {
				limit = { ROOT = { has_character_flag = loan_decisions } }
				set_character_flag = loan_decisions
			}
		}
	}
	
	option = { name = OK }
}


# emf_core.1 [Ruler Undergoing Succession]
#
# Generic succession handler for DUKE+ rulers. If applicable:
# - Add a temporary succession modifier (or tiered series of them)
# - Validate protected_appointment_1 opinions
#
# ROOT = character that now holds the title FROM, and FROMFROM is the previous holder
character_event = {
	id = emf_core.1
	
	is_triggered_only = yes
	hide_window = yes
	
	only_playable = yes
	
	trigger = {
		FROM = { # Title is...
			higher_tier_than = COUNT
			is_primary_holder_title = yes # Inheriting FROM caused it to become primary, so this matters.
		}
	}
	
	immediate = {
		# Succession malus
		if = {
			limit = {
				FROMFROM = { # Not interested in abdications which caused inheritance
					OR = {
						is_dying = yes
						is_alive = no
					}
				}
				FROM = { is_primary_type_title = no } # Nor pope, holy orders, etc.
				NOT = { has_character_modifier = emf_mod_recent_succession } # Nor repeating ourselves
			}
			add_character_modifier = { name = emf_mod_recent_succession duration = 1825 }
			if = {
				limit = { ai = yes }
				add_character_modifier = {
					name = emf_mod_recent_succession_t3
					duration = 730
					hidden = yes
				}
			}
			if = {
				limit = { ai = no }
				add_character_modifier = {
					name = emf_mod_recent_succession_t1
					duration = 365
					hidden = yes
				}
				FROM = { save_event_target_as = emf_tier_title }
				character_event = { id = emf_core.2 days = 365 }
			}
		}
		if = {
			limit = { primary_title = { has_law = protected_appointment_0 } }
			emf_laws_protected_appointment_0_validate_opinion_effect = yes
		}
		if = {
			limit = { primary_title = { has_law = protected_appointment_1 } }
			emf_laws_protected_appointment_1_validate_opinion_effect = yes
		}
	}
}


character_event = {
	id = emf_core.2
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		ai = no
		NOR = {
			lower_tier_than = event_target:emf_tier_title
			primary_title = { is_primary_type_title = yes }
		}
	}
	
	immediate = {
		remove_character_modifier = emf_mod_recent_succession_t1
		add_character_modifier = {
			name = emf_mod_recent_succession_t2
			duration = 365
			hidden = yes
		}
		character_event = { id = emf_core.3 days = 365 }
	}
}

character_event = {
	id = emf_core.3
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		ai = no
		NOR = {
			lower_tier_than = event_target:emf_tier_title
			primary_title = { is_primary_type_title = yes }
		}
	}
	
	immediate = {
		remove_character_modifier = emf_mod_recent_succession_t2
		add_character_modifier = {
			name = emf_mod_recent_succession_t3
			duration = 365
			hidden = yes
		}
		character_event = { id = emf_core.4 days = 365 }
	}
}

character_event = {
	id = emf_core.4
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		ai = no
		NOR = {
			lower_tier_than = event_target:emf_tier_title
			primary_title = { is_primary_type_title = yes }
		}
	}
	
	immediate = {
		remove_character_modifier = emf_mod_recent_succession_t3
		add_character_modifier = {
			name = emf_mod_recent_succession_t4
			duration = 365
			hidden = yes
		}
	}
}


# emf_core.10 [Male That's Reached Adulthood]
#
# Pre-inherit any strong claims that mother may have on_adulthood as weak, uninheritable claims.
character_event = {
	id = emf_core.10
	
	is_triggered_only = yes
	hide_window = yes
	
	only_men = yes
	
	trigger = {
		mother = {
			any_claim = {
				higher_tier_than = BARON
				holder_scope = {
					NOT = { character = ROOT }
				}
				ROOT = {
					NOT = { has_claim = PREV }
					mother = {
						has_strong_claim = PREVPREV
					}
				}
				NOT = {
					succ_law_title = {
						has_law = true_cognatic_succession
					}
				}
			}
		}
	}
	
	immediate = {
		mother = {
			any_claim = {
				limit = {
					higher_tier_than = BARON
					holder_scope = {
						NOT = { character = ROOT }
					}
					ROOT = {
						NOT = { has_claim = PREV }
						mother = {
							has_strong_claim = PREVPREV
						}
					}
					NOT = {
						succ_law_title = {
							has_law = true_cognatic_succession
						}
					}
				}
				add_weak_claim = ROOT
			}
		}
	}
}


# emf_core.11
# Remove monk/nun/etc. traits upon assuming a title -- title xfer on_action
character_event = {
	id = emf_core.11
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		OR = {
			trait = monk
			trait = nun
			trait = desert_father
			trait = desert_mother
		}
	}
	
	immediate = {
		remove_trait = monk
		remove_trait = nun
		remove_trait = desert_father
		remove_trait = desert_mother
		clr_character_flag = title_monk
		clr_character_flag = title_nun
		remove_special_character_title = MONK_BROTHER
		remove_special_character_title = NUN_SISTER
	}
}


# emf_core.12 [Duke+ Ruler]
#
# Reset years_of_peace variable when in qualifying wars <MTTH>
character_event = {
	id = emf_core.12

	hide_window = yes

	only_playable = yes

	trigger = {
		higher_real_tier_than = COUNT
		emf_peace_trigger = no
		check_variable = { which = years_of_peace value = 0.1 }
	}

	mean_time_to_happen = {
		days = 1
	}

	immediate = {
		set_variable = { which = years_of_peace value = 0 }
	}
}


# emf_core.25
# 
# Prevent the ERE from gaining the k_orthodox title-- or rather, when
# they do, fix the situation.
character_event = {
	id = emf_core.25
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		FROM = { title = k_orthodox }
		OR = {
			has_landed_title = e_byzantium
			has_landed_title = e_roman_empire
		}
	}
	
	immediate = {
		log = "WARNING: ERE gained k_orthodox somehow, granting to random priest..."
		
		create_random_priest = {
			random_traits = yes
			female = no
			dynasty = none
			culture = ROOT
			religion = orthodox
		}
		new_character = {
			k_orthodox = { grant_title = PREV }
			b_hagiasophia = {
				if = {
					limit = {
						holder_scope = {
							OR = {
								character = ROOT
								is_liege_or_above = ROOT
								AND = {
									ai = yes
									NOT = { any_liege = { ai = no } }
								}
							}
						}
					}
					grant_title = PREV
				}
			}
			set_defacto_liege = ROOT
		}
		if = {
			limit = { religion_group = muslim }
			set_government_type = muslim_government
			break = yes
		}
		set_government_type = feudal_government
	}
}


# emf_core.26
#
# Duke- or higher-tier AI ruler marries a lowborn (on_marriage)
# Inspired by Rylock's nearly-identical event Plus.361
character_event = {
	id = emf_core.26
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		new_character = { dynasty = none }
		FROM = {
			higher_real_tier_than = COUNT
			ai = yes
		}
	}
	
	immediate = {
		new_character = { dynasty = father_bastard }
	}
}


# For emf_core.30-emf_core.31, see emf_hre_map.txt


# emf_core.40 [Ruler]
#
# Refill levies of held barony titles marked or targeted for refill.
# Useful as a hack to properly refill holding levies when
# we'd normally be inclined to just use `refill_holding_levy = yes`
# immediately somewhere (such as converting a tribal settlement to
# a non-tribal). Instead, invoke this at least 3 days after the fact
# to achieve the desired effect.
#
# The caller can either set the title flag emf_refill_levy on those
# titles that require refilling, or they can use an event target with
# emf_core.41 instead.
character_event = {
	id = emf_core.40
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		any_title_under = {
			limit = {
				tier = BARON
				had_title_flag = {
					flag = emf_refill_levy
					days = 3
				}
			}
			clr_title_flag = emf_refill_levy
			refill_holding_levy = yes
		}
	}
}


# emf_core.41 [Character]
# 
# Alternate version of emf_core.40 in which the title which needs its
# levies refilled is saved in event_target:emf_refill_levy_title. If
# the given title is higher tier than a single barony, it will refill
# all the levies under it de jure.
character_event = {
	id = emf_core.41
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		event_target:emf_refill_levy_title = {
			if = {
				limit = { tier = BARON }
				refill_holding_levy = yes
				break = yes
			}
			any_de_jure_vassal_title = {
				limit = { tier = BARON }
				refill_holding_levy = yes
			}
		}
	}
}

# For emf_core.50, see emf_core_map.txt (SWMH only)


# emf_core.60
# AI automatically abandons NAPs on appropriate characters (adapted from a dummy decision written by Rylock)
character_event = {
	id = emf_core.60
	
	hide_window = yes
	
	only_playable = yes
	min_age = 16
	prisoner = no
	only_capable = yes
	
	trigger = {
		ai = yes
		NOR = {
			trait = content
			trait = craven
			trait = incapable
			trait = imbecile
			trait = nun
			trait = monk
			trait = desert_mother
			trait = desert_father
			trait = in_hiding
			holy_order = yes
			mercenary = yes
			any_liege = {
				OR = {
					holy_order = yes
					mercenary = yes
				}
			}
		}
		any_non_aggression_pact_character = {
			any_demesne_title = {
				claimed_by = ROOT
				OR = {
					ROOT = { has_strong_claim = PREV }
					AND = {
						ROOT = { has_weak_claim = PREV }
						OR = {
							is_pretender = yes # Checks vs ROOT character
							holder_scope = { has_regent = yes }
							AND = {
								ROOT = { is_female = no }
								holder_scope = { is_female = yes }
							}
							is_contested = yes # Is already being contested in some form of Claim or Succession War
						}
					}
				}
			}
			OR = {
				NOT = { reverse_opinion = { who = ROOT value = 25 } }
				AND = {
					NOT = { reverse_opinion = { who = ROOT value = 50 } }
					ROOT = {
						OR = {
							trait = deceitful
							trait = ambitious
							trait = envious
							trait = proud
							trait = brave
						}
					}
				}
			}
			NOR = {
				is_allied_with = ROOT
				is_married = ROOT
				any_close_relative = { is_married = ROOT }
				ROOT = { any_heir_title = { holder = PREVPREV } }
				reverse_has_opinion_modifier = { who = ROOT modifier = opinion_hostile_family }
				reverse_has_opinion_modifier = { who = ROOT modifier = in_non_aggression_pact }
			}
		}
	}
	
	mean_time_to_happen = {
		days = 1
	}
	
	immediate = {
		random_non_aggression_pact_character = {
			limit = {
				any_demesne_title = {
					claimed_by = ROOT
					OR = {
						ROOT = { has_strong_claim = PREV }
						AND = {
							ROOT = { has_weak_claim = PREV }
							OR = {
								is_pretender = yes # Checks vs ROOT character
								holder_scope = { has_regent = yes }
								AND = {
									ROOT = { is_female = no }
									holder_scope = { is_female = yes }
								}
								is_contested = yes # Is already being contested in some form of Claim or Succession War
							}
						}
					}
				}
				OR = {
					NOT = { reverse_opinion = { who = ROOT value = 25 } }
					AND = {
						NOT = { reverse_opinion = { who = ROOT value = 50 } }
						ROOT = {
							OR = {
								trait = deceitful
								trait = ambitious
								trait = envious
								trait = proud
								trait = brave
							}
						}
					}
				}
				NOR = {
					is_allied_with = ROOT
					is_married = ROOT
					any_close_relative = { is_married = ROOT }
					ROOT = { any_heir_title = { holder = PREVPREV } }
					reverse_has_opinion_modifier = { who = ROOT modifier = opinion_hostile_family }
					reverse_has_opinion_modifier = { who = ROOT modifier = in_non_aggression_pact }
				}
			}
			reverse_opinion = { who = ROOT modifier = opinion_hostile_family years = 3 }
		}
	}
}

# emf_core.65
# Feudalize a province by whatever means necessary, preferring historical castle-holders,
# but without flipping counties between (sub)realms. As last resort, try to build a new castle.
#
# NOTE: when referring to the "count" or "baron" below, literal title holder is meant-- _nothing at all_ is
# assumed about the tier of these character(s) -- in fact, they might even be the same dude [somehow].
province_event = {
	id = emf_core.65
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		NOT = { capital_holding = { holding_type = castle } }
	}
	
	immediate = {
		owner = { save_event_target_as = emf_count }
		random_province_holding = { # A feudal castle-holder of COUNT+ tier over/under county holder
			limit = {
				holding_type = castle
				owner = {
					higher_tier_than = BARON
					is_feudal = yes
					OR = {
						character = event_target:emf_count
						is_liege_or_above = event_target:emf_count
						is_vassal_or_below = event_target:emf_count
					}
				}
			}
			save_event_target_as = emf_castle
			owner = { save_event_target_as = emf_baron }
			break = yes
		}
		random_province_holding = { # A historical feudal castle-holder over/under county holder
			limit = {
				holding_type = castle
				owner = {
					historical = yes
					is_feudal = yes
					OR = {
						character = event_target:emf_count
						is_liege_or_above = event_target:emf_count
						is_vassal_or_below = event_target:emf_count
					}
				}
			}
			save_event_target_as = emf_castle
			owner = { save_event_target_as = emf_baron }
			break = yes
		}
		random_province_holding = { # Any feudal castle-holder over/under county holder
			limit = {
				holding_type = castle
				owner = {
					is_feudal = yes
					OR = {
						character = event_target:emf_count
						is_liege_or_above = event_target:emf_count
						is_vassal_or_below = event_target:emf_count
					}
				}
			}
			save_event_target_as = emf_castle
			owner = { save_event_target_as = emf_baron }
			break = yes
		}
		random_province_holding = { # Steal the castle from a non-feudal over/under county holder
			limit = {
				holding_type = castle
				owner = {
					OR = {
						character = event_target:emf_count
						is_liege_or_above = event_target:emf_count
						is_vassal_or_below = event_target:emf_count
					}
				}
			}
			save_event_target_as = emf_castle
			break = yes
		}
		if = {
			limit = { NOT = { has_empty_holding = yes } }
			break = yes # No hope
		}
		# Build the castle ourselves
		build_holding = { type = castle }
		random_province_holding = {
			limit = { holding_type = castle }
			save_event_target_as = emf_castle
		}
	}
	
	option = {
		name = OK
		if = {
			limit = { NOT = { event_target:emf_castle = { always = yes } } }
			break = yes # No hope
		}
		if = {
			limit = { NOT = { event_target:emf_baron = { always = yes } } }
			owner = {
				create_character = {
					random_traits = yes
					dynasty = random
					female = no
					religion = THIS
					culture = THIS
				}
				new_character = {
					save_event_target_as = emf_baron
					if = {
						limit = { religion_group = indian_group }
						add_trait = kshatriya
						character_event = { id = RoI.30121 }
					}
					grant_title_no_opinion = event_target:emf_castle
					if = {
						limit = { NOT = { religion_group = muslim } }
						set_government_type = feudal_government
					}
					if = {
						limit = { religion_group = muslim }
						set_government_type = muslim_government
					}
				}
			}
		}
		owner = {
			liege = { save_event_target_as = emf_count_liege }
		}
		# Flip province capital holding to the castle & give the county title to its baron
		event_target:emf_castle = {
			make_capital_holding = yes
			dejure_liege_title = {
				save_event_target_as = emf_county
				grant_title_no_opinion = event_target:emf_baron
			}
		}
		# Try to vassalize the new county holder to the original liege of the prior county holder, who may of course
		# actually be their own liege (and if this doesn't work due to relative tier after granting the county, then
		# that's WAD too by design)
		event_target:emf_baron = {
			if = {
				limit = { lower_tier_than = event_target:emf_count_liege }
				set_defacto_liege = event_target:emf_count_liege
				emf_liege_change_effect = yes
			}
		}
		# If the old county holder [now] only has titles which are de jure vassal to the county, then vassalize him
		# to the new county holder. If he has no titles at all, vassalize him to his original liege in case he
		# randomly jumped courts to some count in Mozambique or something.
		event_target:emf_count = {
			if = {
				limit = { is_ruler = no }
				if = {
					limit = { character = event_target:emf_count_liege } # Was already independent, so
					set_defacto_liege = event_target:emf_baron # ... assign him to the new county holder
					emf_liege_change_effect = yes
					break = yes
				}
				set_defacto_liege = event_target:emf_count_liege # Should already be in this court, but JIC
				break = yes
			}
			if = {
				limit = {
					NOT = {
						any_demesne_title = {
							NOT = { de_jure_liege = event_target:emf_county }
						}
					}
				}
				set_defacto_liege = event_target:emf_baron
				emf_liege_change_effect = yes
			}
		}
	}
}


# emf_core.1000
# Toggle global EMF debug flag
character_event = {
	id = emf_core.1000

	is_triggered_only = yes
	hide_window = yes

	immediate = {
		if = {
			limit = { has_global_flag = emf_debug }
			clr_global_flag = emf_debug
			break = yes
		}
		set_global_flag = emf_debug
	}
}
