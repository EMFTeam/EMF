# -*- ck2.events -*-


namespace = emf_core

# emf_core.0 [Player]
#
# on_death handler for player characters. Inherits intrigue
# menu character flag state, clears heir focus/amibition, etc.
character_event = {
	id = emf_core.0

	is_triggered_only = yes
	hide_window = yes

	ai = no

	immediate = {
		current_heir = {
			if = {
				limit = { ROOT = { has_flag = emf_toggle_customization_off } }
				set_flag = emf_toggle_customization_off
			}
			if = {
				limit = { ROOT = { has_flag = emf_toggle_employment } }
				set_flag = emf_toggle_employment
			}
			if = {
				limit = { ROOT = { has_flag = emf_show_loan_decisions } }
				set_flag = emf_show_loan_decisions
			}
			clear_focus = yes
			cancel_ambition = yes
		}
	}

	option = { name = OK }
}


# emf_core.1 [Ruler Undergoing Succession]
#
# Generic succession handler for DUKE+ rulers. If applicable:
# - Add a temporary succession modifier (or tiered series of them)
# - Validate protected_appointment_1 opinions
#
# ROOT = character that now holds the title FROM, and FROMFROM is the previous holder
character_event = {
	id = emf_core.1

	is_triggered_only = yes
	hide_window = yes

	only_playable = yes

	trigger = {
		FROM = { # Title is...
			higher_tier_than = COUNT
			is_primary_holder_title = yes # Inheriting FROM caused it to become primary, so this matters.
		}
	}

	immediate = {
		# Succession malus:
		if = {
			limit = {
				FROMFROM = { # Not interested in abdications which caused inheritance
					OR = {
						is_dying = yes
						is_alive = no
					}
				}
				FROM = { is_primary_type_title = no } # Nor pope, holy orders, etc.
			}
			character_event = { id = emf_core.2 days = 1 }
		}
		# Protected Appointments opinion validation:
		if = {
			limit = { FROM = { has_law = protected_appointment_0 } }
			emf_laws_protected_appointment_0_validate_opinion = yes
		}
		if = {
			limit = { FROM = { has_law = protected_appointment_1 } }
			emf_laws_protected_appointment_1_validate_opinion = yes
		}
	}
}

# emf_core.2 -- continuation of emf_core.1 after 1 day for succession malus
character_event = {
	id = emf_core.2

	is_triggered_only = yes
	hide_window = yes

	only_playable = yes

	immediate = {
		remove_character_modifiers = { modifier = emf_recent_succession amount = 5 } # Reset any previous modifiers
		if = {
			limit = { ai = no }
			add_character_modifier = { name = emf_recent_succession duration = 1825 stacking = yes }
			add_character_modifier = { name = emf_recent_succession duration = 1460 stacking = yes }
			add_character_modifier = { name = emf_recent_succession duration = 1095 stacking = yes }
		}
		add_character_modifier = { name = emf_recent_succession duration = 730 stacking = yes }
		add_character_modifier = { name = emf_recent_succession duration = 365 stacking = yes }
	}
}

# emf_core.5 -- distribute wealth of dying ruler to eligible heir children. primary heir gets 4 shares, other
# eligible-for-inheritance direct progeny get 2 shares, and bastards that are otherwise eligible for inheritance
# get 1 share. standard version. [on_death]
character_event = {
	id = emf_core.5

	is_triggered_only = yes # on_death
	hide_window = yes

	only_playable = yes

	trigger = {
		NOT = { religion_group = muslim }
		is_theocracy = no
		OR = {
			is_republic = no
			is_patrician = yes
		}
		mercenary = no
		holy_order = no
		# Don't bother splitting wealth if it's going to be a paltry amount or if it's going to be a debt:
		wealth > 100
		# Need at least a direct heir or any child that could inherit were they not a bastard or a Free Investiture
		# bishop nominee and are of the gender preferred by ROOT's gender succession law:
		OR = {
			player_heir = { is_alive = yes }
			any_child = {
				emf_is_preferred_gender_for_laws_of_PREV = yes
				emf_can_inherit_if_not_bastard_or_bishop_nominee = yes
			}
		}
	}

	immediate = {
		#log = "DEBUG: emf_core.5: dying ruler shall distribute wealth: [This.EMF_GetDebugName]"
		export_to_variable = { which = local_wealth value = treasury }
		#log = " ----> Treasury: [local_wealth.GetValue]"
		#log = " ----> Allocating shares:"
		set_variable = { which = local_shares value = 0 }
		player_heir = {
			set_flag = emf_tmp_allocated_shares
			#log = " ------> Direct heir gets 8 shares: [This.EMF_GetDebugName]"
			change_variable = { which = local_shares value = 8 }
		}
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_allocated_shares }
				emf_is_preferred_gender_for_laws_of_PREV = yes
				emf_can_inherit_if_not_bishop_nominee = yes
			}
			set_flag = emf_tmp_allocated_shares
			#log = " ------> Legitimate direct progeny gets 4 shares: [This.EMF_GetDebugName]"
			change_variable = { which = local_shares value = 4 }
		}
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_allocated_shares }
				emf_is_preferred_gender_for_laws_of_PREV = yes
				emf_can_inherit_if_not_bastard_or_bishop_nominee = yes
			}
			set_flag = emf_tmp_allocated_shares
			#log = " ------> Bastard direct progeny gets 2 shares: [This.EMF_GetDebugName]"
			change_variable = { which = local_shares value = 2 }
		}
		# Calculate share value:
		set_variable = { which = local_share_value which = local_wealth }
		divide_variable = { which = local_share_value which = local_shares }
		#log = " ----> Total shares: [local_shares.GetValue]"
		#log = " ----> Share value: [local_share_value.GetValue]"
		# Transfer total shares' value to each of the 3 classes' treasuries:
		#log = " ----> Transferring inheritance:"
		# For player_heir (8x):
		set_variable = { which = local_value which = local_share_value }
		multiply_variable = { which = local_value value = 8 }
		player_heir = {
			wealth = local_value
			#log = " ------> Direct heir: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		# For legit direct progeny (4x):
		set_variable = { which = local_value which = local_share_value }
		multiply_variable = { which = local_value value = 4 }
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_paid_share_value }
				emf_is_preferred_gender_for_laws_of_PREV = yes
				emf_can_inherit_if_not_bishop_nominee = yes
			}
			wealth = local_value
			#log = " ------> Legitimate direct progeny: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		# For bastard direct progeny (2x):
		set_variable = { which = local_value which = local_share_value }
		multiply_variable = { which = local_value value = 2 }
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_paid_share_value }
				emf_is_preferred_gender_for_laws_of_PREV = yes
				emf_can_inherit_if_not_bastard_or_bishop_nominee = yes
			}
			wealth = local_value
			#log = " ------> Bastard direct progeny: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		# We're done, so clear temporary flags:
		player_heir = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		any_child = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		# And clear our wealth from our ledger, since it's all been distributed:
		clear_wealth = yes
	}
}

# emf_core.6 -- split wealth inheritance under Mirath. [on_death]
character_event = {
	id = emf_core.6

	is_triggered_only = yes # on_death
	hide_window = yes

	only_playable = yes
	religion_group = muslim

	trigger = {
		is_theocracy = no
		OR = {
			is_republic = no
			is_patrician = yes
		}
		mercenary = no
		holy_order = no
		# Don't bother splitting wealth if it's going to be a paltry amount or if it's going to be a debt:
		wealth > 100
		# Need at least a direct heir or any child that could inherit were they not a bastard or a Free Investiture
		# bishop nominee and are of the gender preferred by ROOT's gender succession law:
		OR = {
			player_heir = { is_alive = yes }
			any_child = { emf_can_inherit_if_not_bastard_or_bishop_nominee = yes }
			mother = { is_alive = yes }
			father = { is_alive = yes }
			is_married = yes
		}
	}

	immediate = {
		#log = "DEBUG: emf_core.6: dying ruler shall distribute wealth under Mirath: [This.EMF_GetDebugName]"
		export_to_variable = { which = local_wealth value = treasury }
		#log = " ----> Treasury: [local_wealth.GetValue]"
		#log = " ----> Allocating shares:"
		set_variable = { which = local_shares value = 0 }
		player_heir = {
			set_flag = emf_tmp_allocated_shares
			if = {
				limit = { is_female = yes }
				#log = " ------> Female, direct heir gets 4 shares: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 4 }
			}
			else = {
				#log = " ------> Direct heir gets 8 shares: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 8 }
			}
		}
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_allocated_shares }
				emf_can_inherit_if_not_bishop_nominee = yes
			}
			set_flag = emf_tmp_allocated_shares
			if = {
				limit = { is_female = yes }
				#log = " ------> Female, legitimate direct progeny gets 2 shares: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 2 }
			}
			else = {
				#log = " ------> Legitimate direct progeny gets 4 shares: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 4 }
			}
		}
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_allocated_shares }
				emf_can_inherit_if_not_bastard_or_bishop_nominee = yes
			}
			set_flag = emf_tmp_allocated_shares
			if = {
				limit = { is_female = yes }
				#log = " ------> Female, bastard direct progeny gets 1 share: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 1 }
			}
			else = {
				#log = " ------> Bastard direct progeny gets 2 shares: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 2 }
			}
		}
		mother = {
			if = {
				limit = { NOT = { has_flag = emf_tmp_allocated_shares } }
				set_flag = emf_tmp_allocated_shares
				#log = " ------> Mother gets 1 share: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 1 }
			}
		}
		father = {
			if = {
				limit = { NOT = { has_flag = emf_tmp_allocated_shares } }
				set_flag = emf_tmp_allocated_shares
				#log = " ------> Father gets 2 shares: [This.EMF_GetDebugName]"
				change_variable = { which = local_shares value = 2 }
			}
		}
		spouse = {
			if = {
				limit = { NOT = { has_flag = emf_tmp_allocated_shares } }
				set_flag = emf_tmp_allocated_shares
				if = {
					limit = { is_female = yes }
					#log = " ------> Female spouse gets 1 share: [This.EMF_GetDebugName]"
					change_variable = { which = local_shares value = 1 }
				}
				else = {
					#log = " ------> Male spouse gets 2 shares: [This.EMF_GetDebugName]"
					change_variable = { which = local_shares value = 2 }
				}
			}
		}
		# Calculate share value:
		set_variable = { which = local_share_value which = local_wealth }
		divide_variable = { which = local_share_value which = local_shares }
		#log = " ----> Total shares: [local_shares.GetValue]"
		#log = " ----> Share value: [local_share_value.GetValue]"
		# Transfer total shares' value to each of the classes' treasuries:
		#log = " ----> Transferring inheritance:"
		# For player_heir (4-8x):
		set_variable = { which = local_value which = local_share_value }
		player_heir = {
			if = {
				limit = { is_female = yes }
				multiply_variable = { which = local_value value = 4 }
				#log = " ------> Direct female heir: [local_value.GetValue]"
			}
			else = {
				multiply_variable = { which = local_value value = 8 }
				#log = " ------> Direct male heir: [local_value.GetValue]"
			}
			wealth = local_value
			set_flag = emf_tmp_paid_share_value
		}
		# For legit male direct progeny (4x):
		set_variable = { which = local_value which = local_share_value }
		multiply_variable = { which = local_value value = 4 }
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_paid_share_value }
				is_female = no
				emf_can_inherit_if_not_bishop_nominee = yes
			}
			wealth = local_value
			#log = " ------> Legitimate male direct progeny: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		# For bastard male direct progeny, legit female direct progeny, living father, and male spouse (2x):
		set_variable = { which = local_value which = local_share_value }
		multiply_variable = { which = local_value value = 2 }
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_paid_share_value }
				is_female = no
				emf_can_inherit_if_not_bastard_or_bishop_nominee = yes
			}
			wealth = local_value
			#log = " ------> Bastard male direct progeny: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_paid_share_value }
				is_female = yes
				emf_can_inherit_if_not_bishop_nominee = yes
			}
			wealth = local_value
			#log = " ------> Legitimate female direct progeny: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		father = {
			if = {
				limit = { NOT = { has_flag = emf_tmp_paid_share_value } }
				wealth = local_value
				#log = " ------> Father: [local_value.GetValue]"
				set_flag = emf_tmp_paid_share_value
			}
		}
		spouse = {
			if = {
				limit = {
					NOT = { has_flag = emf_tmp_paid_share_value }
					is_female = no
				}
				#log = " ------> Male spouse: [local_value.GetValue]"
				wealth = local_value
				set_flag = emf_tmp_paid_share_value
			}
		}
		# For bastard female direct progeny, living mother, and female primary spouse (1x):
		set_variable = { which = local_value which = local_share_value }
		any_child = {
			limit = {
				NOT = { has_flag = emf_tmp_paid_share_value }
				is_female = yes
				emf_can_inherit_if_not_bastard_or_bishop_nominee = yes
			}
			wealth = local_value
			#log = " ------> Female bastard direct progeny: [local_value.GetValue]"
			set_flag = emf_tmp_paid_share_value
		}
		mother = {
			if = {
				limit = { NOT = { has_flag = emf_tmp_paid_share_value } }
				#log = " ------> Mother: [local_value.GetValue]"
				wealth = local_value
				set_flag = emf_tmp_paid_share_value
			}
		}
		spouse = {
			if = {
				limit = {
					NOT = { has_flag = emf_tmp_paid_share_value }
					is_female = yes
				}
				#log = " ------> Female spouse: [local_value.GetValue]"
				wealth = local_value
				set_flag = emf_tmp_paid_share_value
			}
		}
		# We're done, so clear temporary flags:
		player_heir = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		any_child = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		father = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		mother = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		spouse = {
			clr_flag = emf_tmp_allocated_shares
			clr_flag = emf_tmp_paid_share_value
		}
		# And clear our wealth from our ledger, since it's all been distributed:
		clear_wealth = yes
	}
}

# emf_core.10 -- if game rule Non-Dynastic Succession is 'Allowed', prevent game over with non-dynastic heir on_death.
character_event = {
	id = emf_core.10

	is_triggered_only = yes
	hide_window = yes

	ai = no

	trigger = {
		has_game_rule = { name = non_dynastic_succession value = on }
		is_nomadic = no
		is_merchant_republic = no
		OR = {
			capital_scope = {
				county = {
					holder = ROOT
					current_heir = {
						ai = yes
						NOT = { dynasty = ROOT }
					}
				}
			}
			AND = {
				OR = {
					mercenary = yes
					holy_order = yes
				}
				current_heir = {
					ai = yes
					NOT = { dynasty = ROOT }
				}
			}
		}
		NOT = { has_global_flag = emf_nondynastic_succession_disabled }
	}

	immediate = {
		if = {
			limit = {
				capital_scope = {
					county = {
						holder = ROOT
						current_heir = {
							ai = yes
							NOT = { dynasty = ROOT }
						}
					}
				}
			}
			capital_scope = { county = { current_heir = { save_event_target_as = emf_real_heir } } }
		}
		else = {
			current_heir = { save_event_target_as = emf_real_heir }
		}
		event_target:emf_real_heir = {
			if = {
				limit = { is_lowborn = yes }
				dynasty = father_bastard
			}
			ROOT = {
				create_character = {
					religion = PREV
					culture = PREV
					dynasty = PREV
					trait = immortal
				}
				new_character = { save_event_target_as = emf_sleeve }
			}
			dynasty = ROOT
			character_event = { id = emf_core.11 days = 1 }
		}
	}
}

# emf_core.11 -- continuation after 1 day of emf_core.10 (or invoked immediately after abdication in emf_willfully_abdicate)
character_event = {
	id = emf_core.11

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		event_target:emf_sleeve = { always = yes }
	}

	immediate = {
		dynasty = event_target:emf_sleeve
		event_target:emf_sleeve = {
			remove_trait = immortal
			emf_vanish_character = yes
		}
		recalc_succession = yes
	}
}

# emf_core.15 -- AI liege with only a barony usurps a county from an AI vassal
#
# Called from ai_claim_county_if_baron decision & emf_cb_on_success_posttitle
character_event = {
	id = emf_core.15

	is_triggered_only = yes
	hide_window = yes

	ai = yes

	trigger = {
		higher_tier_than = COUNT
		# war = no # commented-out so that it can be called immediately on war end
		is_landed = yes
		is_patrician = no
		num_of_count_titles == 0
		any_realm_title = {
			tier = COUNT
			owner = { ai = yes }
		}
	}

	immediate = {
		random_realm_title = {
			limit = {
				tier = COUNT
				owner = { ai = yes }
			}
			preferred_limit = {
				ROOT = {
					primary_title = {
						capital_scope = {
							county = {
								title = PREVPREVPREVPREV
							}
						}
					}
				}
			}
			preferred_limit = {
				owner = { NOT = { has_dynasty_flag = emf_is_historical } }
				location = { is_capital = no }
			}
			preferred_limit = {
				owner = {
					NOT = { has_dynasty_flag = emf_is_historical }
					num_of_count_titles > 1
				}
			}
			preferred_limit = {
				location = { is_capital = no }
			}
			preferred_limit = {
				owner = { num_of_count_titles > 1 }
			}
			preferred_limit = {
				owner = { NOT = { has_dynasty_flag = emf_is_historical } }
			}
			grant_title_no_opinion = { target = ROOT type = revoke }
			any_direct_de_jure_vassal_title = {
				limit = {
					owner = {
						is_liege_or_above = ROOT
						ai = yes
					}
					is_preferred_holding_type = ROOT
				}
				grant_title_no_opinion = { target = ROOT type = revoke }
			}
			if = {
				limit = { NOT = { location = { capital_holding = { is_preferred_holding_type = ROOT } } } }
				random_direct_de_jure_vassal_title = {
					limit = {
						holder = ROOT
						is_preferred_holding_type = ROOT
					}
					make_capital_holding = yes
				}
			}
			ROOT = { capital = PREV }
		}
		character_event = { id = emf_borders.0 }
	}
}

character_event = {
	id = emf_core.20

	is_triggered_only = yes
	hide_window = yes

	only_rulers = yes

	trigger = {
		trait = peasant_leader
		FROM = {
			temporary = no
			rebel = no
			NOT = { has_flag = emf_revolt }
			OR = {
				is_landless_type_title = no
				mercenary = yes
				holy_order = yes
				controls_religion = yes
				ROOT = { is_patrician = yes }
			}
		}
	}

	immediate = {
		add_trait = peasant_ruler
		if = {
			limit = { is_lowborn = yes }
			dynasty = father_bastard
		}
		log = "INFO: emf_core.20: [Root.EMF_GetDebugName], a Peasant Leader, has become a Peasant Ruler! gained title: [From.EMF_GetDebugTitleNameWithDeJureLieges]"
	}
}

# emf_core.21
#
# Event triggered by on_new_holder to set the `emf_global_hre` global event target when `e_hre` or `e_hre_french`
# are gained. Assumes that the titles cannot be created if the alternative title is already held.
character_event = {
	id = emf_core.21

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		FROM = {
			OR = {
				title = e_hre
				title = e_hre_french
			}
		}
		NOT = { FROMFROM = { always = yes } }
	}

	immediate = {
		if = {
			limit = { FROM = { title = e_hre } }
			e_hre = { save_global_event_target_as = emf_global_hre }
		}
		else = {
			e_hre_french = { save_global_event_target_as = emf_global_hre }
		}
		if = {
			limit = {
				e_hre = { has_holder = yes }
				e_hre_french = { has_holder = yes }
			}
			log = "WARNING: emf_core.21: after creating [From.GetID], both e_hre and e_hre_french are held!"
		}
	}
}

# emf_core.22
#
# Event triggered by on_new_holder to set the `emf_global_byz` global event target when `e_byzantium` or
# `e_roman_empire` are gained. Assumes that the titles cannot be created if the alternative title is already held,
# with the exception of `e_roman_empire`.
character_event = {
	id = emf_core.22

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		FROM = {
			emf_is_roman_empire = yes
		}
		NOT = { FROMFROM = { always = yes } }
	}

	immediate = {
		if = {
			limit = { FROM = { title = e_byzantium } }
			e_byzantium = { save_global_event_target_as = emf_global_byz }
		}
		else = {
			e_roman_empire = { save_global_event_target_as = emf_global_byz }
		}
		if = {
			limit = {
				e_byzantium = { has_holder = yes }
				e_roman_empire = { has_holder = yes }
				FROM = { NOT = { title = e_roman_empire } } # The RE is created before auto-destroying the ERE
			}
			log = "WARNING: emf_core.22: after creating [From.GetID], both e_byzantium and e_roman_empire are held!"
		}
	}
}

# emf_core.23 -- Ensure nobody ever holds e_null by any means!
character_event = {
	id = emf_core.23

	is_triggered_only = yes # on_action: on_new_holder, on_new_holder_usurpation
	hide_window = yes

	trigger = {
		FROM = { title = e_null }
	}

	immediate = {
		log = "ERROR: emf_core.23: [Root.GetTitledName] (#[Root.GetID]/[Root.PrimaryTitle.GetID]) somehow gained [From.GetID]! auto-destroying it!"
		destroy_landed_title = FROM
		FROM = { set_flag = emf_defunct } # Not that anything is going to pay attention this part...
	}
}


# emf_core.26
#
# Duke- or higher-tier AI ruler marries a lowborn (on_marriage)
# 
# 1) Give the lowborn spouse a dynasty
#
# 2) In order to alleviate the extreme advantage players have over selecting good wives for their genes (or at
# least avoiding terrible genes in marriage selection): in this case of an AI DUKE+ ruler marrying a lowborn, we
# know that the lowborn was a last-ditch random choice and that there is no hard-coded AI preference toward
# positive phenotypes (except for those that boost fertility), so...
#
#    We initialize the AI spouse's genes (i.e., what will matter for their offspring) to be strictly neutral or
# positive (only heterozygous or homozygous dominant allele pairs, with a distribution preferring the average state). We also must
# remove any negative genetic traits that are subject to Mendelian inheritance for this to work properly. Polygenic
# traits, by far the most common type, do not need removal.
character_event = {
	id = emf_core.26

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		new_character = {
			is_lowborn = yes
		}
		FROM = {
			higher_real_tier_than = COUNT
			ai = yes
		}
	}

	immediate = {
		new_character = {
			dynasty = father_bastard
			emf_dna_reverse_homozygous_recessive = yes
			# Must also remove negative traits subject to Mendelian inheritance, or else their presence will override their
			# gene flags during genetic inheritance (not an issue with traits subject to Polygenic inheritance):
			emf_dna_remove_negative_mendelian_traits = yes
			if = {
				limit = {
					is_ruler = no
					NOT = { religion = FROM }
				}
				religion = FROM
			}
		}
	}
}

# emf_core.27
# Remove monk/nun/etc. traits upon assuming a title -- title xfer on_action
character_event = {
	id = emf_core.27

	is_triggered_only = yes
	hide_window = yes

	trigger = {
		is_ascetic_trigger = yes
	}

	immediate = {
		log = "INFO: emf_core.27: ascetic gained a title: [This.EMF_GetDebugName]"
		log = " ---> title: [From.EMF_GetDebugTitleNameWithDeJureLieges]"
		remove_trait = monk
		remove_trait = nun
		remove_trait = desert_father
		remove_trait = desert_mother
		remove_trait = muni
		remove_trait = aryika
		remove_trait = bhikkhu
		remove_trait = bhikkhuni
		remove_trait = sanyasi
		remove_trait = sanyasini
		clr_flag = title_monk
		clr_flag = title_nun
		clr_flag = title_desert_father
		clr_flag = title_desert_mother
		clr_flag = is_desert_mother_father
		remove_special_character_title = MONK_BROTHER
		remove_special_character_title = NUN_SISTER
		remove_special_character_title = DESERT_FATHER_TITLE
		remove_special_character_title = DESERT_MOTHER_TITLE
	}
}

# emf_core.28 -- Upon the death of a feudal, tribal, or nomadic ruler, if their heir is a ruler and none of those 3
# groups of government types AND is lower tier than the title they'd be assuming, then force them to abdicate and
# adopt the correct government type.
character_event = {
	id = emf_core.28

	is_triggered_only = yes # on_death
	hide_window = yes

	only_playable = yes

	trigger = {
		OR = {
			is_feudal = yes
			is_tribal = yes
			is_nomadic = yes
		}
		current_heir = {
			is_ruler = yes
			lower_tier_than = ROOT
			OR = {
				is_theocracy = yes
				is_republic = yes
			}
			is_patrician = no
		}
	}

	immediate = {
		current_heir = {
			emf_willfully_abdicate = yes
			if = {
				limit = { NOT = { vassal_of = ROOT } }
				move_character = ROOT
			}
			emf_set_government_to_match_PREV = yes
		}
	}
}

# emf_core.40 [Ruler]
#
# Refill levies of held barony titles marked or targeted for refill.
# Useful as a hack to properly refill holding levies when
# we'd normally be inclined to just use `refill_holding_levy = yes`
# immediately somewhere (such as converting a tribal settlement to
# a non-tribal). Instead, invoke this at least 3 days after the fact
# to achieve the desired effect.
#
# The caller can either set the title flag emf_refill_levy on those
# titles that require refilling, or they can use an event target with
# emf_core.41 instead.
character_event = {
	id = emf_core.40
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		any_title_under = {
			limit = {
				tier = BARON
				had_flag = {
					flag = emf_refill_levy
					days = 3
				}
			}
			clr_flag = emf_refill_levy
			refill_holding_levy = yes
		}
	}
}


# emf_core.41 [Character]
#
# Alternate version of emf_core.40 in which the title which needs its
# levies refilled is saved in event_target:emf_refill_levy_title. If
# the given title is higher tier than a single barony, it will refill
# all the levies under it de jure.
character_event = {
	id = emf_core.41
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		event_target:emf_refill_levy_title = {
			if = {
				limit = { tier = BARON }
				refill_holding_levy = yes
				break = yes
			}
			any_de_jure_vassal_title = {
				limit = { tier = BARON }
				refill_holding_levy = yes
			}
		}
	}
}

# For emf_core.50, see emf_core_map.txt (SWMH only)

# emf_core.55 -- Impose costs of war when armies are in unowned territory
character_event = {
	id = emf_core.55

	hide_window = yes

	ai = no
	war = yes

	trigger = {
		any_war = {
			OR = {
				attacker = { character = ROOT }
				defender = { character = ROOT }
			}
			NOR = {
				using_cb = peasant_revolt
				using_cb = heretic_revolt
				using_cb = emf_revolt_religious
				using_cb = liberation_revolt
				using_cb = cb_minor_clan_revolt
				using_cb = emf_decadence_revolt
			}
		}
		any_army = { location = { owner_under_ROOT = no } }
	}

	mean_time_to_happen = { days = 0 }

	immediate = {
		remove_character_modifier = war_costs_modifier
		add_character_modifier = { name = war_costs_modifier duration = 60 hidden = yes }
	}
}

# emf_core.56 -- Give AIs a break every once in awhile on heavily negative opinions due to raised vassal levies
character_event = {
	id = emf_core.56

	is_triggered_only = yes # on_bi_yearly_pulse
	hide_window = yes

	only_playable = yes
	ai = yes

	trigger = {
		any_vassal = {
			opinion_levy_raised_days = { who = ROOT days = 365 }
			ai = yes
		}
	}

	immediate = {
		any_vassal = {
			limit = {
				opinion_levy_raised_days = { who = ROOT days = 365 }
				ai = yes
			}
			set_opinion_levy_raised_days = { who = ROOT days = 0 }
		}
	}
}

# emf_core.60
# AI automatically abandons NAPs on appropriate characters (adapted from a dummy decision written by Rylock)
character_event = {
	id = emf_core.60

	hide_window = yes

	only_playable = yes
	min_age = 16
	prisoner = no
	only_capable = yes
	ai = yes

	trigger = {
		NOR = {
			trait = content
			trait = craven
			is_incapable = yes
			trait = imbecile
			is_ascetic_trigger = yes
			is_inaccessible_trigger = yes
			holy_order = yes
			mercenary = yes
			any_liege = {
				OR = {
					holy_order = yes
					mercenary = yes
				}
			}
		}
		any_non_aggression_pact_character = {
			any_demesne_title = { emf_cb_can_press_claim = yes }
			OR = {
				NOT = { reverse_opinion = { who = ROOT value = 25 } }
				AND = {
					NOT = { reverse_opinion = { who = ROOT value = 50 } }
					ROOT = {
						OR = {
							trait = deceitful
							trait = ambitious
							trait = envious
							trait = proud
							trait = brave
						}
					}
				}
			}
			NOR = {
				is_allied_with = ROOT
				is_married = ROOT
				any_close_relative = { is_married = ROOT }
				ROOT = { any_heir_title = { holder = PREVPREV } }
				reverse_has_opinion_modifier = { who = ROOT modifier = opinion_hostile_family }
				reverse_has_opinion_modifier = { who = ROOT modifier = in_non_aggression_pact }
			}
		}
	}

	mean_time_to_happen = {
		days = 1
	}

	immediate = {
		random_non_aggression_pact_character = {
			limit = {
				any_demesne_title = { emf_cb_can_press_claim = yes }
				OR = {
					NOT = { reverse_opinion = { who = ROOT value = 25 } }
					AND = {
						NOT = { reverse_opinion = { who = ROOT value = 50 } }
						ROOT = {
							OR = {
								trait = deceitful
								trait = ambitious
								trait = envious
								trait = proud
								trait = brave
							}
						}
					}
				}
				NOR = {
					is_allied_with = ROOT
					is_married = ROOT
					any_close_relative = { is_married = ROOT }
					ROOT = { any_heir_title = { holder = PREVPREV } }
					reverse_has_opinion_modifier = { who = ROOT modifier = opinion_hostile_family }
					reverse_has_opinion_modifier = { who = ROOT modifier = in_non_aggression_pact }
				}
			}
			reverse_opinion = { who = ROOT modifier = opinion_hostile_family years = 3 }
		}
	}
}

# emf_core.65
# Recalculate capital-contiguous provinces for an independent realm
#
# Called on annual maintenance throughout the year as well as explicitly
# from all CBs' on_success_posttitle -> emf_cb_on_success_posttitle -> here
# specifically for the realms potentially affected by territory change due to the war.
# Also called on_startup.
character_event = {
	id = emf_core.65

	is_triggered_only = yes
	hide_window = yes

	only_independent = yes # Note that this filters-out revolt top realms too, which is intentional

	trigger = {
		capital_scope = { owner = { character = ROOT } }
	}

	immediate = {
		# log = "DEBUG: emf_core.65: calculating emf_capital_connected for [This.GetTitledFirstName] of [This.PrimaryTitle.GetBaseName] ([This.GetID]/[This.PrimaryTitle.GetID])"
		any_realm_province = { # Remove old state
			limit = { owner = { same_realm = ROOT } } # any_realm_province includes provinces in which we have a realm barony
			clr_flag = emf_capital_connected
			clr_flag = emf_capital_connected_by_seazone
		}
		capital_scope = { # Seed the capital
			set_flag = emf_capital_connected
			any_neighbor_province = { # Handle near-OPMs quickly (loop below makes it technically redundant)
				limit = { owner = { same_realm = ROOT } }
				set_flag = emf_capital_connected
			}
		}
		while = {
			limit = {
				any_realm_province = {
					owner = { same_realm = ROOT }
					NOT = { has_flag = emf_capital_connected }
					any_neighbor_province = {
						owner = { same_realm = ROOT }
						has_flag = emf_capital_connected
					}
				}
			}
			any_realm_province = {
				limit = {
					owner = { same_realm = ROOT }
					NOT = { has_flag = emf_capital_connected }
					any_neighbor_province = {
						owner = { same_realm = ROOT }
						has_flag = emf_capital_connected
					}
				}
				set_flag = emf_capital_connected
			}
		}
		# Now path through any independent revolt realms of ours
		any_war = {
			limit = {
				defender = { character = ROOT }
				attacker = {
					liege = { character = PREV } #independent = yes and any_independent_ruler exclude revolts
					OR = {
						in_revolt = yes
						liege_before_war = { character = ROOT }
					}
				}
			}
			attacker = {
				reverse_opinion = { who = ROOT modifier = opinion_my_rebel }
				any_realm_province = {
					limit = { owner_under_PREV = yes }
					clr_flag = emf_capital_connected
					clr_flag = emf_capital_connected_by_seazone
				}
			}
		}
		while = {
			limit = {
				any_opinion_modifier_target = {
					reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
					any_realm_province = {
						owner_under_PREV = yes
						NOT = { has_flag = emf_capital_connected }
						any_neighbor_province = {
							has_flag = emf_capital_connected
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
				}
			}
			any_opinion_modifier_target = {
				limit = {
					reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
					any_realm_province = {
						owner_under_PREV = yes
						NOT = { has_flag = emf_capital_connected }
						any_neighbor_province = {
							has_flag = emf_capital_connected
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
				}
				any_realm_province = {
					limit = {
						owner_under_PREV = yes
						NOT = { has_flag = emf_capital_connected }
						any_neighbor_province = {
							has_flag = emf_capital_connected
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
					set_flag = emf_capital_connected
				}
			}
		}
		# Now, mark the provinces which are capital-connected only via a seazone adjacency
		any_realm_province = {
			limit = {
				port = yes
				owner = { same_realm = ROOT }
				NOT = { has_flag = emf_capital_connected }
				any_neighbor_province = {
					is_land = no
					any_neighbor_province = {
						NOT = { province = PREVPREV } # Not the original port from which we started
						owner = { same_realm = ROOT }
						has_flag = emf_capital_connected
					}
				}
			}
			set_flag = emf_capital_connected_by_seazone # might want to make this into a modifier w/ slight malus
		}
		# Now, do the same through any of our revolt realms
		any_opinion_modifier_target = {
			limit = { reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel } }
			any_realm_province = {
				limit = {
					port = yes
					owner_under_PREV = yes
					NOT = { has_flag = emf_capital_connected }
					any_neighbor_province = {
						is_land = no
						any_neighbor_province = {
							has_flag = emf_capital_connected
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
				}
				set_flag = emf_capital_connected_by_seazone
			}
		}
		# Now, mark those provinces connected to provinces which are capital-connected only via a seazone adjacency
		while = {
			limit = {
				any_realm_province = {
					owner = { same_realm = ROOT }
					NOT = { has_flag = emf_capital_connected_by_seazone }
					any_neighbor_province = {
						owner = { same_realm = ROOT }
						has_flag = emf_capital_connected_by_seazone
					}
				}
			}
			any_realm_province = {
				limit = {
					owner = { same_realm = ROOT }
					NOT = { has_flag = emf_capital_connected_by_seazone }
					any_neighbor_province = {
						owner = { same_realm = ROOT }
						has_flag = emf_capital_connected_by_seazone
					}
				}
				set_flag = emf_capital_connected_by_seazone
			}
		}
		# Finally, propogate the capital-connected-via-seazone adjacencies through our rebel realms
		while = {
			limit = {
				any_opinion_modifier_target = {
					reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
					any_realm_province = {
						owner_under_PREV = yes
						NOT = { has_flag = emf_capital_connected_by_seazone }
						any_neighbor_province = {
							has_flag = emf_capital_connected_by_seazone
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
				}
			}
			any_opinion_modifier_target = {
				limit = {
					reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
					any_realm_province = {
						owner_under_PREV = yes
						NOT = { has_flag = emf_capital_connected_by_seazone }
						any_neighbor_province = {
							has_flag = emf_capital_connected_by_seazone
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
				}
				any_realm_province = {
					limit = {
						owner_under_PREV = yes
						NOT = { has_flag = emf_capital_connected_by_seazone }
						any_neighbor_province = {
							has_flag = emf_capital_connected_by_seazone
							owner = {
								top_liege = {
									OR = {
										character = ROOT
										ROOT = {
											any_opinion_modifier_target = {
												reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel }
												character = PREVPREV
											}
										}
									}
								}
							}
						}
					}
					set_flag = emf_capital_connected_by_seazone
				}
			}
		}
		# Cleanup rebel TOMs
		any_opinion_modifier_target = {
			limit = { reverse_has_opinion_modifier = { who = PREV modifier = opinion_my_rebel } }
			reverse_remove_opinion = { who = PREV modifier = opinion_my_rebel }
		}
	}
}

# emf_core.80
# Handle mercenary companies gaining non-mercenary titles -- on_new_holder and on_new_holder_usurpation
character_event = {
	id = emf_core.80

	hide_window = yes
	is_triggered_only = yes

	only_rulers = yes
	ai = yes

	trigger = {
		NOT = { has_flag = skip_titular_duchy }
		any_demesne_title = { mercenary = yes }
		FROM = {
			mercenary = no
			NOT = { has_flag = emf_check_mercenary_titles }
		}
	}

	immediate = {
		add_trait = adventurer
		primary_title = {
			save_event_target_as = mercenary_title
			set_flag = emf_check_mercenary_titles
		}
		# They have 5 years before they must surrender the mercenary title
		isis = {
			character_event = { id = emf_core.81 days = 1825 }
		}
	}
}

character_event = {
	id = emf_core.81

	hide_window = yes
	is_triggered_only = yes

	immediate = {
		# First check if the mercenary holder is at war
		if = {
			limit = {
				event_target:mercenary_title = {
					has_holder = yes
					has_flag = emf_check_mercenary_titles
					holder_scope = {
						ai = yes
						war = yes
						any_demesne_title = { mercenary = no }
					}
				}
			}
			repeat_event = { id = emf_core.81 days = 365 } # Check again in a year
			break = yes
		}
		# The mercenary holder is still a mercenary, not at war, and still has non-mercenary titles
		if = {
			limit = {
				event_target:mercenary_title = {
					has_holder = yes
					has_flag = emf_check_mercenary_titles
					holder_scope = {
						ai = yes
						any_demesne_title = { mercenary = no }
					}
				}
			}
			event_target:mercenary_title = {
				clr_flag = emf_check_mercenary_titles
				# First check if I need to give him a Duke-tier title to replace the mecenary company
				holder_scope = {
					save_event_target_as = current_merc
					if = {
						limit = {
							# Mercenary is landed, has vassals of Count+ tier
							# and currently has no titles of equal or higher rank than the mercenary company
							is_landed = yes
							any_vassal = { higher_tier_than = BARON }
							NOT = {
								any_demesne_title = {
									NOT = { title = event_target:mercenary_title }
									OR = {
										tier = event_target:mercenary_title
										higher_tier_than = event_target:mercenary_title
									}
								}
							}
						}
						# In this case, give him the capital county's de jure duchy if it has no current holder
						# Otherwise, create a titular duchy based on that capital county
						capital_scope = {
							duchy = {
								if = {
									limit = { has_holder = no }
									event_target:current_merc = { set_flag = skip_titular_duchy }
									grant_title = event_target:current_merc
								}
							}
							if = {
								limit = {
									event_target:current_merc = { NOT = { has_flag = skip_titular_duchy } }
								}
								county = {
									create_title = {
										tier = DUKE
										landless = no
										temporary = no
										custom_created = yes
										culture = event_target:current_merc
										holder = event_target:current_merc
										base_title = THIS
										copy_title_laws = yes
									}
								}
							}
							event_target:current_merc = { clr_flag = skip_titular_duchy }
						}
					}
				}
				# Hand off the mercenary company to the current heir
				current_heir = {
					usurp_title_only = PREV
					# Vassalize to the former holder, in case they're high enough tier
					if = {
						limit = { lower_tier_than = event_target:current_merc }
						set_defacto_liege = event_target:current_merc
					}
				}
				# Remove any claims to the company by the former holder
				event_target:current_merc = {
					remove_claim = PREV
					recalc_succession = yes
				}
			}
			break = yes
		}
		event_target:mercenary_title = {
			clr_flag = emf_check_mercenary_titles
		}
	}
}


# emf_core.100 -- autodestroy unnecessary titular titles
character_event = {
	id = emf_core.100

	hide_window = yes

	only_playable = yes
	war = no

	trigger = {
		higher_tier_than = COUNT
		any_demesne_title = {
			is_de_jure_title = no
			emf_can_autodestroy_title = yes
			# Don't just suddenly switch primary title on a player; they can take care of it themselves if wanted
			NAND = {
				ROOT = { ai = no }
				is_primary_holder_title = yes
			}
			# Don't autodestroy titles that the player or his forebears created (while being players)
			NAND = {
				ROOT = { ai = no }
				has_flag = emf_autodestroy_exemption_for_@ROOT
			}
			NOT = { tier = EMPEROR } # Different mechanic handles extra empire titles
			emf_ROOT_has_any_higher_tier_de_jure_title_with_compatible_succ_laws = yes
		}
	}

	mean_time_to_happen = {
		days = 0
	}

	immediate = {
		log = "INFO: emf_core.100: Auto-destroying titular title(s): [This.EMF_GetDebugName]"
		any_demesne_title = {
			limit = {
				is_de_jure_title = no
				emf_can_autodestroy_title = yes
				# Don't just suddenly switch primary title on a player; they can take care of it themselves if wanted
				NAND = {
					ROOT = { ai = no }
					is_primary_holder_title = yes
				}
				# Don't autodestroy titles that the player or his forebears created (while being players)
				NAND = {
					ROOT = { ai = no }
					has_flag = emf_autodestroy_exemption_for_@ROOT
				}
				NOT = { tier = EMPEROR } # Different mechanic handles extra empire titles
				emf_ROOT_has_any_higher_tier_de_jure_title_with_compatible_succ_laws = yes
			}
			log = " --> [This.EMF_GetDebugTitleNameWithDeJureLieges]"
			if = {
				limit = { is_primary_holder_title = yes }
				log = " ----> title is primary, finding new primary title..."
				ROOT = {
					any_demesne_title = {
						count = 1
						limit = {
							is_primary_holder_title_tier = yes
							is_de_jure_title = yes
						}
						score_value = {
							value = 1
							additive_modifier = {
								value = 20
								culture = ROOT
							}
							additive_modifier = {
								value = 20
								culture_group = ROOT
							}
							additive_modifier = {
								value = 10
								ROOT = {
									capital_scope = {
										de_jure_liege_or_above = PREVPREV
									}
								}
							}
						}
						log = " ----> new primary title: [This.EMF_GetDebugTitleNameWithDeJureLieges]"
						emf_make_primary_title = yes
					}
				}
			}
			if = { # Set flag for if the title is an HRE elector title here, for safety reasons and also to make sure things go smoothly if the character holds multiple, auto-destruction-eligible elector titles
				limit = { emf_is_hre_elector_title = yes }
				emf_remove_hre_elector_from_title = yes
				ROOT = {
					log = " ----> title is HRE elector title! Will need to assign new elector title to [This.EMF_GetDebugName] if they are still eligible"
					set_flag = emf_needs_hre_elector_assignment
				}
			}
			# DESTROY! RUIN! DEFUNCT!
			if = {
				limit = { emf_can_safely_autodestroy_title = yes }
				emf_destroy_title = yes
			}
			else = {
				emf_unsafe_destroy_title = yes
			}
			set_flag = emf_autodestroy_defunct
			set_flag = emf_defunct
		}
		# If the title destroyed was an HRE elector title, then try to select a new valid elector title from ROOT's
		# demesne, and replace its PET slot in e_hre *if and only if* we fulfill the potential for being an HRE
		# elector again.
		if = {
			limit = {
				has_flag = emf_needs_hre_elector_assignment
				emf_hre_elector_potential = yes # will be False if ROOT is still an elector
			}
			clr_flag = emf_needs_hre_elector_assignment
			# Then select a new elector title and replace an invalid slot in the elector title PET array:
			emf_select_hre_elector_demesne_title = yes
			event_target:emf_new_elector_title = {
				emf_replace_invalid_hre_elector_title = yes
			}
			clear_event_target = emf_former_elector_title # Probable product of replacement effect
			clear_event_target = emf_new_elector_title
		}
	}
}

# emf_core.101 -- flag player-created titles & mark titular ones exempt from auto-destruction [on_new_holder]
character_event = {
	id = emf_core.101

	is_triggered_only = yes
	hide_window = yes

	ai = no

	trigger = {
		NOT = { FROMFROM = { always = yes } } # Creation only
		FROM = {
			higher_tier_than = BARON # Not concerned about baronies built by a player
			# Is even a candidate for autodestruction:
			is_de_jure_title = no
			emf_can_safely_autodestroy_title = yes
		}
	}

	immediate = {
		FROM = { set_flag = emf_autodestroy_exemption_for_@ROOT }
	}
}

# emf_core.102 -- inherit player-created title autodestroy exemption flags [on_death]
character_event = {
	id = emf_core.102

	is_triggered_only = yes # on_death
	hide_window = yes

	ai = no

	trigger = {
		any_demesne_title = {
			has_flag = emf_autodestroy_exemption_for_@ROOT
		}
		player_heir = { is_alive = yes }
	}

	immediate = {
		player_heir = {
			ROOT = {
				any_demesne_title = {
					limit = {
						has_flag = emf_autodestroy_exemption_for_@ROOT
						is_de_jure_title = no
						emf_can_safely_autodestroy_title = yes
					}
					clr_flag = emf_autodestroy_exemption_for_@ROOT
					set_flag = emf_autodestroy_exemption_for_@PREVPREV # player_heir
				}
			}
		}
	}
}

# emf_core.110 -- general pre-abdication handler, invoked manually everywhere that an abdication can occur in our code by the
#				 scripted effect emf_willfully_abdicate = yes
#
# I can also detect abdication via on_new_holder_inheritance, but for the proper amount of power, we want to be able to
# assess the properties of the abdicator while they still hold all of their titles and no such on_actions have yet executed
# (much like on_death, but this is effectively on_abdicate when using `emf_willfully_abdicate` instead of the vanilla `abdicate`).
character_event = {
	id = emf_core.110

	is_triggered_only = yes
	hide_window = yes

	immediate = {
		log = "INFO: emf_core.110: ruler abdicating: [Root.GetTitledFirstName] [Root.GetOnlyDynastyName] of the [Root.PrimaryTitle.GetFullName] (#[Root.GetID]/[Root.PrimaryTitle.GetID])"
		remove_trait = emf_crowned
		remove_trait = emf_crowned_by_pope
		remove_trait = strong_basileus
		remove_trait = weak_basileus
		remove_trait = crowned_by_priest
		remove_trait = crowned_by_bishop
		remove_trait = crowned_by_pope
		remove_trait = crowned_by_myself
		remove_character_modifiers = { modifier = uncrowned_modifier amount = 30 } 	
		set_variable = { which = uncrowned_count value = 0 }
		remove_trait = karling_usurper
		if = {
			limit = { NOT = { event_target:emf_abdicate_real_heir = { always = yes } } } # Not using abdicate_to
			current_heir = {
				log = "--> abdicating to current heir [This.GetTitledFirstName] [This.GetOnlyDynastyName] (#[This.GetID]) [abdicate]"
				character_event = { id = emf_core.111 } # Adjust government type of heir if necessary
			}
		}
		if = {
			limit = { event_target:emf_abdicate_real_heir = { always = yes } } # Using abdicate_to
			log = "--> abdicating directly to [emf_abdicate_real_heir.GetTitledFirstName] [emf_abdicate_real_heir.GetOnlyDynastyName] (#[emf_abdicate_real_heir.GetID]) [abdicate_to]"
			# Adjust government type of heir if necessary for sanity
			event_target:emf_abdicate_real_heir = { character_event = { id = emf_core.111 } }
		}
	}
}

# emf_core.111 -- helper that puts abdication heir in ROOT scope so that emf_cb_ROOT_ensure_feudal can do its work
#
# NOTE: this only converts the heir to feudal if the title they're about to assume is high enough tier and already feudal,
# among other things
character_event = {
	id = emf_core.111

	is_triggered_only = yes
	hide_window = yes

	trigger = { FROM = { higher_real_tier_than = COUNT } }

	immediate = { FROM = { primary_title = { emf_cb_ROOT_ensure_feudal = yes } } }
}


# emf_core.1000
# Toggle EMF debug mode
character_event = {
	id = emf_core.1000

	is_triggered_only = yes
	hide_window = yes

	immediate = {
		if = {
			limit = { has_global_flag = emf_debug }
			clr_global_flag = emf_debug
			break = yes
		}
		set_global_flag = emf_debug
	}
}
