# -*- ck2.events -*-


namespace = emf_core

# emf_core.0 [Player]
#
# on_death handler for player characters. Inherits intrigue
# menu character flag state for now. Cushy.
character_event = {
	id = emf_core.0
	hide_window = yes
	is_triggered_only = yes
	
	ai = no

	immediate = {
		current_heir = {
			if = {
				limit = { ROOT = { has_character_flag = emf_toggle_customization_off } }
				set_character_flag = emf_toggle_customization_off
			}
			if = {
				limit = { ROOT = { has_character_flag = emf_toggle_employment } }
				set_character_flag = emf_toggle_employment
			}
			if = {
				limit = { ROOT = { has_character_flag = enable_marriage_decisions } }
				set_character_flag = enable_marriage_decisions
			}
			if = {
				limit = { ROOT = { has_character_flag = loan_decisions } }
				set_character_flag = loan_decisions
			}
		}
	}
	
	option = { name = OK }
}


# emf_core.1 [Ruler Undergoing Succession]
#
# Generic succession handler for DUKE+ rulers. If applicable:
# - Add a temporary succession modifier (or tiered series of them)
# - Validate protected_appointment_1 opinions
#
# ROOT = character that now holds the title FROM, and FROMFROM is the previous holder
character_event = {
	id = emf_core.1
	
	is_triggered_only = yes
	hide_window = yes
	
	only_playable = yes
	
	trigger = {
		FROM = { # Title is...
			higher_tier_than = COUNT
			is_primary_holder_title = yes # Inheriting FROM caused it to become primary, so this matters.
		}
	}
	
	immediate = {
		# Succession malus
		if = {
			limit = {
				FROMFROM = { # Not interested in abdications which caused inheritance
					OR = {
						is_dying = yes
						is_alive = no
					}
				}
				FROM = { is_primary_type_title = no } # Nor pope, holy orders, etc.
				NOT = { has_character_modifier = emf_mod_recent_succession } # Nor repeating ourselves
			}
			add_character_modifier = { name = emf_mod_recent_succession duration = 1825 }
			if = {
				limit = { ai = yes }
				add_character_modifier = {
					name = emf_mod_recent_succession_t3
					duration = 730
					hidden = yes
				}
			}
			if = {
				limit = { ai = no }
				add_character_modifier = {
					name = emf_mod_recent_succession_t1
					duration = 365
					hidden = yes
				}
				FROM = { save_event_target_as = emf_tier_title }
				character_event = { id = emf_core.2 days = 365 }
			}
		}
		if = {
			limit = { primary_title = { has_law = protected_appointment_0 } }
			emf_laws_protected_appointment_0_validate_opinion_effect = yes
		}
		if = {
			limit = { primary_title = { has_law = protected_appointment_1 } }
			emf_laws_protected_appointment_1_validate_opinion_effect = yes
		}
	}
}


character_event = {
	id = emf_core.2
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		ai = no
		NOR = {
			lower_tier_than = event_target:emf_tier_title
			primary_title = { is_primary_type_title = yes }
		}
	}
	
	immediate = {
		remove_character_modifier = emf_mod_recent_succession_t1
		add_character_modifier = {
			name = emf_mod_recent_succession_t2
			duration = 365
			hidden = yes
		}
		character_event = { id = emf_core.3 days = 365 }
	}
}

character_event = {
	id = emf_core.3
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		ai = no
		NOR = {
			lower_tier_than = event_target:emf_tier_title
			primary_title = { is_primary_type_title = yes }
		}
	}
	
	immediate = {
		remove_character_modifier = emf_mod_recent_succession_t2
		add_character_modifier = {
			name = emf_mod_recent_succession_t3
			duration = 365
			hidden = yes
		}
		character_event = { id = emf_core.4 days = 365 }
	}
}

character_event = {
	id = emf_core.4
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		ai = no
		NOR = {
			lower_tier_than = event_target:emf_tier_title
			primary_title = { is_primary_type_title = yes }
		}
	}
	
	immediate = {
		remove_character_modifier = emf_mod_recent_succession_t3
		add_character_modifier = {
			name = emf_mod_recent_succession_t4
			duration = 365
			hidden = yes
		}
	}
}


# emf_core.10 [Male That's Reached Adulthood]
#
# Pre-inherit any strong claims that mother may have on_adulthood as weak, uninheritable claims.
character_event = {
	id = emf_core.10
	
	is_triggered_only = yes
	hide_window = yes
	
	only_men = yes
	
	trigger = {
		mother = {
			any_claim = {
				has_holder = yes
				higher_tier_than = BARON
				ROOT = { mother = { has_strong_claim = PREVPREV } }
				NOT = { claimed_by = ROOT }
				NOT = { holder = ROOT }
				succ_law_title = {
					OR = {
						has_law = agnatic_succession
						has_law = cognatic_succession
					}
				}
			}
		}
	}
	
	immediate = {
		mother = {
			any_claim = {
				limit = {
					has_holder = yes
					higher_tier_than = BARON
					ROOT = { mother = { has_strong_claim = PREVPREV } }
					NOT = { claimed_by = ROOT }
					NOT = { holder = ROOT }
					succ_law_title = {
						OR = {
							has_law = agnatic_succession
							has_law = cognatic_succession
						}
					}
				}
				add_weak_claim = ROOT
			}
		}
	}
}


# emf_core.11
# Remove monk/nun/etc. traits upon assuming a title -- title xfer on_action
character_event = {
	id = emf_core.11
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		OR = {
			trait = monk
			trait = nun
			trait = desert_father
			trait = desert_mother
		}
	}
	
	immediate = {
		remove_trait = monk
		remove_trait = nun
		remove_trait = desert_father
		remove_trait = desert_mother
		clr_character_flag = title_monk
		clr_character_flag = title_nun
		remove_special_character_title = MONK_BROTHER
		remove_special_character_title = NUN_SISTER
	}
}


# emf_core.12 [Duke+ Ruler]
#
# Reset years_of_peace variable when in qualifying wars <MTTH>
character_event = {
	id = emf_core.12

	hide_window = yes

	only_playable = yes

	trigger = {
		higher_real_tier_than = COUNT
		emf_peace_trigger = no
		check_variable = { which = years_of_peace value = 0.1 }
	}

	mean_time_to_happen = {
		days = 1
	}

	immediate = {
		set_variable = { which = years_of_peace value = 0 }
	}
}


# emf_core.25
# 
# Prevent the ERE from gaining the k_orthodox title-- or rather, when
# they do, fix the situation.
character_event = {
	id = emf_core.25
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		FROM = { title = k_orthodox }
		OR = {
			has_landed_title = e_byzantium
			has_landed_title = e_roman_empire
		}
	}
	
	immediate = {
		log = "WARNING: ERE gained k_orthodox somehow, granting to random priest..."
		
		create_random_priest = {
			random_traits = yes
			female = no
			dynasty = none
			culture = ROOT
			religion = orthodox
		}
		new_character = {
			k_orthodox = { grant_title = PREV }
			b_hagiasophia = {
				if = {
					limit = { owner_under_ROOT = yes }
					grant_title = PREV
				}
			}
			set_defacto_liege = ROOT
		}
		if = {
			limit = { is_feudal = yes }
			break = yes
		}
		if = {
			limit = { primary_title = { has_law = administration_2 } }
			emf_switch_to_imperial_effect = yes
			break = yes
		}
		emf_switch_to_feudal_gov_effect = yes
	}
}


# emf_core.26
#
# Duke- or higher-tier AI ruler marries a lowborn (on_marriage)
# Inspired by Rylock's nearly-identical event Plus.361
character_event = {
	id = emf_core.26
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		new_character = { dynasty = none }
		FROM = {
			higher_real_tier_than = COUNT
			ai = yes
		}
	}
	
	immediate = {
		new_character = { dynasty = father_bastard }
	}
}


# For emf_core.30-emf_core.31, see emf_hre_map.txt


# emf_core.40 [Ruler]
#
# Refill levies of held barony titles marked or targeted for refill.
# Useful as a hack to properly refill holding levies when
# we'd normally be inclined to just use `refill_holding_levy = yes`
# immediately somewhere (such as converting a tribal settlement to
# a non-tribal). Instead, invoke this at least 3 days after the fact
# to achieve the desired effect.
#
# The caller can either set the title flag emf_refill_levy on those
# titles that require refilling, or they can use an event target with
# emf_core.41 instead.
character_event = {
	id = emf_core.40
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		any_title_under = {
			limit = {
				tier = BARON
				had_title_flag = {
					flag = emf_refill_levy
					days = 3
				}
			}
			clr_title_flag = emf_refill_levy
			refill_holding_levy = yes
		}
	}
}


# emf_core.41 [Character]
# 
# Alternate version of emf_core.40 in which the title which needs its
# levies refilled is saved in event_target:emf_refill_levy_title. If
# the given title is higher tier than a single barony, it will refill
# all the levies under it de jure.
character_event = {
	id = emf_core.41
	hide_window = yes
	is_triggered_only = yes

	immediate = {
		event_target:emf_refill_levy_title = {
			if = {
				limit = { tier = BARON }
				refill_holding_levy = yes
				break = yes
			}
			any_de_jure_vassal_title = {
				limit = { tier = BARON }
				refill_holding_levy = yes
			}
		}
	}
}

# For emf_core.50, see emf_core_map.txt (SWMH only)

# emf_core.60
# AI automatically abandons NAPs on appropriate characters (adapted from a dummy decision written by Rylock)
character_event = {
	id = emf_core.60
	
	hide_window = yes
	
	only_playable = yes
	min_age = 16
	prisoner = no
	only_capable = yes
	
	trigger = {
		ai = yes
		NOR = {
			trait = content
			trait = craven
			trait = incapable
			trait = imbecile
			trait = nun
			trait = monk
			trait = desert_mother
			trait = desert_father
			trait = in_hiding
			holy_order = yes
			mercenary = yes
			any_liege = {
				OR = {
					holy_order = yes
					mercenary = yes
				}
			}
		}
		any_non_aggression_pact_character = {
			any_demesne_title = { emf_cb_can_press_claim = yes }
			OR = {
				NOT = { reverse_opinion = { who = ROOT value = 25 } }
				AND = {
					NOT = { reverse_opinion = { who = ROOT value = 50 } }
					ROOT = {
						OR = {
							trait = deceitful
							trait = ambitious
							trait = envious
							trait = proud
							trait = brave
						}
					}
				}
			}
			NOR = {
				is_allied_with = ROOT
				is_married = ROOT
				any_close_relative = { is_married = ROOT }
				ROOT = { any_heir_title = { holder = PREVPREV } }
				reverse_has_opinion_modifier = { who = ROOT modifier = opinion_hostile_family }
				reverse_has_opinion_modifier = { who = ROOT modifier = in_non_aggression_pact }
			}
		}
	}
	
	mean_time_to_happen = {
		days = 1
	}
	
	immediate = {
		random_non_aggression_pact_character = {
			limit = {
				any_demesne_title = { emf_cb_can_press_claim = yes }
				OR = {
					NOT = { reverse_opinion = { who = ROOT value = 25 } }
					AND = {
						NOT = { reverse_opinion = { who = ROOT value = 50 } }
						ROOT = {
							OR = {
								trait = deceitful
								trait = ambitious
								trait = envious
								trait = proud
								trait = brave
							}
						}
					}
				}
				NOR = {
					is_allied_with = ROOT
					is_married = ROOT
					any_close_relative = { is_married = ROOT }
					ROOT = { any_heir_title = { holder = PREVPREV } }
					reverse_has_opinion_modifier = { who = ROOT modifier = opinion_hostile_family }
					reverse_has_opinion_modifier = { who = ROOT modifier = in_non_aggression_pact }
				}
			}
			reverse_opinion = { who = ROOT modifier = opinion_hostile_family years = 3 }
		}
	}
}

# emf_core.65
# Recalculate capital-contiguous provinces for an independent realm
#
# Called on annual maintenance throughout the year as well as explicitly
# from all CBs' on_success_posttitle -> emf_cb_on_success_posttitle_effect -> here
# specifically for the realms affected by territory change due to the war.
character_event = {
	id = emf_core.65
	
	is_triggered_only = yes
	hide_window = yes
	
	only_independent = yes # Note that this filters-out revolt top realms too, which is intentional
	
	trigger = {
		capital_scope = { owner = { character = ROOT } }
	}
	
	immediate = {
		any_realm_province = { clr_province_flag = emf_capital_connected }
		capital_scope = {
			set_province_flag = emf_capital_connected
			any_neighbor_province = {
				limit = { owner = { same_realm = ROOT } }
				set_province_flag = emf_capital_connected
			}
		}
		character_event = { id = emf_core.66 }
	}
}

# emf_core.66
# Recursive component of emf_core.65 -- spread the contagion
#
# Note that this *isn't* the same sort of design as the old CK2+ implementation
# of whole-world recursive province marking, which was _dramatically_ more
# computationally complex. [Note that CK2Plus no longer calculates in that way either.]
character_event = {
	id = emf_core.66
	
	is_triggered_only = yes
	hide_window = yes
	
	trigger = {
		any_realm_province = {
			NOT = { has_province_flag = emf_capital_connected }
			any_neighbor_province = {
				owner = { same_realm = ROOT }
				has_province_flag = emf_capital_connected
			}
		}
	}
	
	immediate = {
		any_realm_province = {
			limit = {
				NOT = { has_province_flag = emf_capital_connected }
				any_neighbor_province = {
					owner = { same_realm = ROOT }
					has_province_flag = emf_capital_connected
				}
			}
			set_province_flag = emf_capital_connected
		}
		any_realm_province = {
			limit = {
				NOT = { has_province_flag = emf_capital_connected }
				any_neighbor_province = {
					owner = { same_realm = ROOT }
					has_province_flag = emf_capital_connected
				}
			}
			set_province_flag = emf_capital_connected
		}
		any_realm_province = {
			limit = {
				NOT = { has_province_flag = emf_capital_connected }
				any_neighbor_province = {
					owner = { same_realm = ROOT }
					has_province_flag = emf_capital_connected
				}
			}
			set_province_flag = emf_capital_connected
		}
		repeat_event = { id = emf_core.66 }
	}
}


# emf_core.1000
# Toggle EMF debug mode
character_event = {
	id = emf_core.1000

	is_triggered_only = yes
	hide_window = yes

	immediate = {
		if = {
			limit = { has_global_flag = emf_debug }
			clr_global_flag = emf_debug
			break = yes
		}
		set_global_flag = emf_debug
	}
}
